[
  {
    "id": 16401,
    "schema": "extensions",
    "name": "uuid_generate_v4",
    "language": "c",
    "definition": "uuid_generate_v4",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2950,
    "return_type": "uuid",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16387,
    "schema": "pgbouncer",
    "name": "get_auth",
    "language": "plpgsql",
    "definition": "\nBEGIN\n    RAISE WARNING 'PgBouncer auth request: %', p_usename;\n\n    RETURN QUERY\n    SELECT usename::TEXT, passwd::TEXT FROM pg_catalog.pg_shadow\n    WHERE usename = p_usename;\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename text)\n RETURNS TABLE(username text, password text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RAISE WARNING 'PgBouncer auth request: %', p_usename;\n\n    RETURN QUERY\n    SELECT usename::TEXT, passwd::TEXT FROM pg_catalog.pg_shadow\n    WHERE usename = p_usename;\nEND;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "p_usename",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "table",
        "name": "username",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "password",
        "type_id": 25,
        "has_default": null
      }
    ],
    "argument_types": "p_usename text",
    "identity_argument_types": "p_usename text",
    "return_type_id": 2249,
    "return_type": "TABLE(username text, password text)",
    "return_type_relation_id": null,
    "is_set_returning_function": true,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": null
  },
  {
    "id": 16404,
    "schema": "extensions",
    "name": "digest",
    "language": "c",
    "definition": "pg_digest",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.digest(text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "text, text",
    "identity_argument_types": "text, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16414,
    "schema": "extensions",
    "name": "decrypt_iv",
    "language": "c",
    "definition": "pg_decrypt_iv",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea, bytea, text",
    "identity_argument_types": "bytea, bytea, bytea, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16415,
    "schema": "extensions",
    "name": "gen_random_bytes",
    "language": "c",
    "definition": "pg_random_bytes",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_random_bytes$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      }
    ],
    "argument_types": "integer",
    "identity_argument_types": "integer",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16411,
    "schema": "extensions",
    "name": "encrypt",
    "language": "c",
    "definition": "pg_encrypt",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea, text",
    "identity_argument_types": "bytea, bytea, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16412,
    "schema": "extensions",
    "name": "decrypt",
    "language": "c",
    "definition": "pg_decrypt",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea, text",
    "identity_argument_types": "bytea, bytea, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16413,
    "schema": "extensions",
    "name": "encrypt_iv",
    "language": "c",
    "definition": "pg_encrypt_iv",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea, bytea, text",
    "identity_argument_types": "bytea, bytea, bytea, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16416,
    "schema": "extensions",
    "name": "gen_random_uuid",
    "language": "c",
    "definition": "pg_random_uuid",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.gen_random_uuid()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/pgcrypto', $function$pg_random_uuid$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2950,
    "return_type": "uuid",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16399,
    "schema": "extensions",
    "name": "uuid_generate_v1mc",
    "language": "c",
    "definition": "uuid_generate_v1mc",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2950,
    "return_type": "uuid",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16393,
    "schema": "extensions",
    "name": "uuid_nil",
    "language": "c",
    "definition": "uuid_nil",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.uuid_nil()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_nil$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2950,
    "return_type": "uuid",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16501,
    "schema": "auth",
    "name": "uid",
    "language": "sql",
    "definition": "\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.sub', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')\n  )::uuid\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION auth.uid()\n RETURNS uuid\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.sub', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')\n  )::uuid\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2950,
    "return_type": "uuid",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16503,
    "schema": "auth",
    "name": "email",
    "language": "sql",
    "definition": "\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION auth.email()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16394,
    "schema": "extensions",
    "name": "uuid_ns_dns",
    "language": "c",
    "definition": "uuid_ns_dns",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2950,
    "return_type": "uuid",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16395,
    "schema": "extensions",
    "name": "uuid_ns_url",
    "language": "c",
    "definition": "uuid_ns_url",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_url()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_url$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2950,
    "return_type": "uuid",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16396,
    "schema": "extensions",
    "name": "uuid_ns_oid",
    "language": "c",
    "definition": "uuid_ns_oid",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2950,
    "return_type": "uuid",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16397,
    "schema": "extensions",
    "name": "uuid_ns_x500",
    "language": "c",
    "definition": "uuid_ns_x500",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2950,
    "return_type": "uuid",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16398,
    "schema": "extensions",
    "name": "uuid_generate_v1",
    "language": "c",
    "definition": "uuid_generate_v1",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2950,
    "return_type": "uuid",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16400,
    "schema": "extensions",
    "name": "uuid_generate_v3",
    "language": "c",
    "definition": "uuid_generate_v3",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "namespace",
        "type_id": 2950,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "name",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "namespace uuid, name text",
    "identity_argument_types": "namespace uuid, name text",
    "return_type_id": 2950,
    "return_type": "uuid",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16446,
    "schema": "extensions",
    "name": "try_cast_double",
    "language": "plpgsql",
    "definition": "\n  BEGIN\n    BEGIN\n      RETURN inp::double precision;\n    EXCEPTION\n      WHEN OTHERS THEN RETURN NULL;\n    END;\n  END;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.try_cast_double(inp text)\n RETURNS double precision\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n  BEGIN\n    BEGIN\n      RETURN inp::double precision;\n    EXCEPTION\n      WHEN OTHERS THEN RETURN NULL;\n    END;\n  END;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "inp",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "inp text",
    "identity_argument_types": "inp text",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16445,
    "schema": "extensions",
    "name": "verify",
    "language": "sql",
    "definition": "\n  SELECT\n    jwt.header AS header,\n    jwt.payload AS payload,\n    jwt.signature_ok AND tstzrange(\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'nbf')),\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'exp'))\n    ) @> CURRENT_TIMESTAMP AS valid\n  FROM (\n    SELECT\n      convert_from(extensions.url_decode(r[1]), 'utf8')::json AS header,\n      convert_from(extensions.url_decode(r[2]), 'utf8')::json AS payload,\n      r[3] = extensions.algorithm_sign(r[1] || '.' || r[2], secret, algorithm) AS signature_ok\n    FROM regexp_split_to_array(token, '\\.') r\n  ) jwt\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.verify(token text, secret text, algorithm text DEFAULT 'HS256'::text)\n RETURNS TABLE(header json, payload json, valid boolean)\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n  SELECT\n    jwt.header AS header,\n    jwt.payload AS payload,\n    jwt.signature_ok AND tstzrange(\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'nbf')),\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'exp'))\n    ) @> CURRENT_TIMESTAMP AS valid\n  FROM (\n    SELECT\n      convert_from(extensions.url_decode(r[1]), 'utf8')::json AS header,\n      convert_from(extensions.url_decode(r[2]), 'utf8')::json AS payload,\n      r[3] = extensions.algorithm_sign(r[1] || '.' || r[2], secret, algorithm) AS signature_ok\n    FROM regexp_split_to_array(token, '\\.') r\n  ) jwt\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "token",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "secret",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "algorithm",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "table",
        "name": "header",
        "type_id": 114,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "payload",
        "type_id": 114,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "valid",
        "type_id": 16,
        "has_default": null
      }
    ],
    "argument_types": "token text, secret text, algorithm text DEFAULT 'HS256'::text",
    "identity_argument_types": "token text, secret text, algorithm text",
    "return_type_id": 2249,
    "return_type": "TABLE(header json, payload json, valid boolean)",
    "return_type_relation_id": null,
    "is_set_returning_function": true,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16560,
    "schema": "extensions",
    "name": "grant_pg_cron_access",
    "language": "plpgsql",
    "definition": "\nBEGIN\n  IF EXISTS (\n    SELECT\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_cron'\n  )\n  THEN\n    grant usage on schema cron to postgres with grant option;\n\n    alter default privileges in schema cron grant all on tables to postgres with grant option;\n    alter default privileges in schema cron grant all on functions to postgres with grant option;\n    alter default privileges in schema cron grant all on sequences to postgres with grant option;\n\n    alter default privileges for user supabase_admin in schema cron grant all\n        on sequences to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on tables to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on functions to postgres with grant option;\n\n    grant all privileges on all tables in schema cron to postgres with grant option;\n    revoke all on table cron.job from postgres;\n    grant select on table cron.job to postgres with grant option;\n  END IF;\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_cron'\n  )\n  THEN\n    grant usage on schema cron to postgres with grant option;\n\n    alter default privileges in schema cron grant all on tables to postgres with grant option;\n    alter default privileges in schema cron grant all on functions to postgres with grant option;\n    alter default privileges in schema cron grant all on sequences to postgres with grant option;\n\n    alter default privileges for user supabase_admin in schema cron grant all\n        on sequences to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on tables to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on functions to postgres with grant option;\n\n    grant all privileges on all tables in schema cron to postgres with grant option;\n    revoke all on table cron.job from postgres;\n    grant select on table cron.job to postgres with grant option;\n  END IF;\nEND;\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 3838,
    "return_type": "event_trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16409,
    "schema": "extensions",
    "name": "gen_salt",
    "language": "c",
    "definition": "pg_gen_salt",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "text",
    "identity_argument_types": "text",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16402,
    "schema": "extensions",
    "name": "uuid_generate_v5",
    "language": "c",
    "definition": "uuid_generate_v5",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "namespace",
        "type_id": 2950,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "name",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "namespace uuid, name text",
    "identity_argument_types": "namespace uuid, name text",
    "return_type_id": 2950,
    "return_type": "uuid",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16405,
    "schema": "extensions",
    "name": "digest",
    "language": "c",
    "definition": "pg_digest",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.digest(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, text",
    "identity_argument_types": "bytea, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16406,
    "schema": "extensions",
    "name": "hmac",
    "language": "c",
    "definition": "pg_hmac",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "text, text, text",
    "identity_argument_types": "text, text, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16407,
    "schema": "extensions",
    "name": "hmac",
    "language": "c",
    "definition": "pg_hmac",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea, text",
    "identity_argument_types": "bytea, bytea, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16408,
    "schema": "extensions",
    "name": "crypt",
    "language": "c",
    "definition": "pg_crypt",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.crypt(text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_crypt$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "text, text",
    "identity_argument_types": "text, text",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16410,
    "schema": "extensions",
    "name": "gen_salt",
    "language": "c",
    "definition": "pg_gen_salt_rounds",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      }
    ],
    "argument_types": "text, integer",
    "identity_argument_types": "text, integer",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16417,
    "schema": "extensions",
    "name": "pgp_sym_encrypt",
    "language": "c",
    "definition": "pgp_sym_encrypt_text",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "text, text",
    "identity_argument_types": "text, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16418,
    "schema": "extensions",
    "name": "pgp_sym_encrypt_bytea",
    "language": "c",
    "definition": "pgp_sym_encrypt_bytea",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, text",
    "identity_argument_types": "bytea, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16502,
    "schema": "auth",
    "name": "role",
    "language": "sql",
    "definition": "\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION auth.role()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16698,
    "schema": "pgsodium",
    "name": "crypto_sign_init",
    "language": "c",
    "definition": "pgsodium_crypto_sign_init",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_init()\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_init$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16699,
    "schema": "pgsodium",
    "name": "crypto_sign_update",
    "language": "c",
    "definition": "pgsodium_crypto_sign_update",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_update(state bytea, message bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_update$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "state",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "state bytea, message bytea",
    "identity_argument_types": "state bytea, message bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16424,
    "schema": "extensions",
    "name": "pgp_sym_decrypt_bytea",
    "language": "c",
    "definition": "pgp_sym_decrypt_bytea",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, text, text",
    "identity_argument_types": "bytea, text, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16425,
    "schema": "extensions",
    "name": "pgp_pub_encrypt",
    "language": "c",
    "definition": "pgp_pub_encrypt_text",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "text, bytea",
    "identity_argument_types": "text, bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16426,
    "schema": "extensions",
    "name": "pgp_pub_encrypt_bytea",
    "language": "c",
    "definition": "pgp_pub_encrypt_bytea",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea",
    "identity_argument_types": "bytea, bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16427,
    "schema": "extensions",
    "name": "pgp_pub_encrypt",
    "language": "c",
    "definition": "pgp_pub_encrypt_text",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "text, bytea, text",
    "identity_argument_types": "text, bytea, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16562,
    "schema": "extensions",
    "name": "grant_pg_net_access",
    "language": "plpgsql",
    "definition": "\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_net'\n  )\n  THEN\n    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n\n    ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n    ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n\n    ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n    ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n\n    REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n    REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n\n    GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n    GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n  END IF;\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_net'\n  )\n  THEN\n    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n\n    ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n    ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n\n    ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n    ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n\n    REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n    REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n\n    GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n    GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n  END IF;\nEND;\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 3838,
    "return_type": "event_trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16579,
    "schema": "extensions",
    "name": "pg_stat_statements_info",
    "language": "c",
    "definition": "pg_stat_statements_info",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)\n RETURNS record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_info$function$\n",
    "args": [
      {
        "mode": "out",
        "name": "dealloc",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "stats_reset",
        "type_id": 1184,
        "has_default": null
      }
    ],
    "argument_types": "OUT dealloc bigint, OUT stats_reset timestamp with time zone",
    "identity_argument_types": "OUT dealloc bigint, OUT stats_reset timestamp with time zone",
    "return_type_id": 2249,
    "return_type": "record",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16603,
    "schema": "extensions",
    "name": "pgrst_ddl_watch",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  cmd record;\nBEGIN\n  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()\n  LOOP\n    IF cmd.command_tag IN (\n      'CREATE SCHEMA', 'ALTER SCHEMA'\n    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'\n    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'\n    , 'CREATE VIEW', 'ALTER VIEW'\n    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'\n    , 'CREATE FUNCTION', 'ALTER FUNCTION'\n    , 'CREATE TRIGGER'\n    , 'CREATE TYPE', 'ALTER TYPE'\n    , 'CREATE RULE'\n    , 'COMMENT'\n    )\n    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp\n    AND cmd.schema_name is distinct from 'pg_temp'\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; ",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  cmd record;\nBEGIN\n  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()\n  LOOP\n    IF cmd.command_tag IN (\n      'CREATE SCHEMA', 'ALTER SCHEMA'\n    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'\n    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'\n    , 'CREATE VIEW', 'ALTER VIEW'\n    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'\n    , 'CREATE FUNCTION', 'ALTER FUNCTION'\n    , 'CREATE TRIGGER'\n    , 'CREATE TYPE', 'ALTER TYPE'\n    , 'CREATE RULE'\n    , 'COMMENT'\n    )\n    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp\n    AND cmd.schema_name is distinct from 'pg_temp'\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 3838,
    "return_type": "event_trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16612,
    "schema": "extensions",
    "name": "grant_pg_graphql_access",
    "language": "plpgsql",
    "definition": "\nDECLARE\n    func_is_graphql_resolve bool;\nBEGIN\n    func_is_graphql_resolve = (\n        SELECT n.proname = 'resolve'\n        FROM pg_event_trigger_ddl_commands() AS ev\n        LEFT JOIN pg_catalog.pg_proc AS n\n        ON ev.objid = n.oid\n    );\n\n    IF func_is_graphql_resolve\n    THEN\n        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func\n        DROP FUNCTION IF EXISTS graphql_public.graphql;\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language sql\n        as $$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $$;\n\n        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last\n        -- function in the extension so we need to grant permissions on existing entities AND\n        -- update default permissions to any others that are created after `graphql.resolve`\n        grant usage on schema graphql to postgres, anon, authenticated, service_role;\n        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;\n        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;\n        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;\n\n        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles\n        grant usage on schema graphql_public to postgres with grant option;\n        grant usage on schema graphql to postgres with grant option;\n    END IF;\n\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    func_is_graphql_resolve bool;\nBEGIN\n    func_is_graphql_resolve = (\n        SELECT n.proname = 'resolve'\n        FROM pg_event_trigger_ddl_commands() AS ev\n        LEFT JOIN pg_catalog.pg_proc AS n\n        ON ev.objid = n.oid\n    );\n\n    IF func_is_graphql_resolve\n    THEN\n        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func\n        DROP FUNCTION IF EXISTS graphql_public.graphql;\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language sql\n        as $$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $$;\n\n        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last\n        -- function in the extension so we need to grant permissions on existing entities AND\n        -- update default permissions to any others that are created after `graphql.resolve`\n        grant usage on schema graphql to postgres, anon, authenticated, service_role;\n        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;\n        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;\n        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;\n\n        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles\n        grant usage on schema graphql_public to postgres with grant option;\n        grant usage on schema graphql to postgres with grant option;\n    END IF;\n\nEND;\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 3838,
    "return_type": "event_trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16674,
    "schema": "pgsodium",
    "name": "crypto_pwhash_saltgen",
    "language": "c",
    "definition": "pgsodium_crypto_pwhash_saltgen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_pwhash_saltgen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_pwhash_saltgen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16691,
    "schema": "pgsodium",
    "name": "crypto_kx_client_session_keys",
    "language": "c",
    "definition": "pgsodium_crypto_kx_client_session_keys",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_kx_client_session_keys(client_pk bytea, client_sk bytea, server_pk bytea)\n RETURNS pgsodium.crypto_kx_session\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_kx_client_session_keys$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "client_pk",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "client_sk",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "server_pk",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "client_pk bytea, client_sk bytea, server_pk bytea",
    "identity_argument_types": "client_pk bytea, client_sk bytea, server_pk bytea",
    "return_type_id": 16690,
    "return_type": "pgsodium.crypto_kx_session",
    "return_type_relation_id": 16688,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16692,
    "schema": "pgsodium",
    "name": "crypto_kx_server_session_keys",
    "language": "c",
    "definition": "pgsodium_crypto_kx_server_session_keys",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_kx_server_session_keys(server_pk bytea, server_sk bytea, client_pk bytea)\n RETURNS pgsodium.crypto_kx_session\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_kx_server_session_keys$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "server_pk",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "server_sk",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "client_pk",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "server_pk bytea, server_sk bytea, client_pk bytea",
    "identity_argument_types": "server_pk bytea, server_sk bytea, client_pk bytea",
    "return_type_id": 16690,
    "return_type": "pgsodium.crypto_kx_session",
    "return_type_relation_id": 16688,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16693,
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha512_keygen",
    "language": "c",
    "definition": "pgsodium_crypto_auth_hmacsha512_keygen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512_keygen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16708,
    "schema": "pgsodium",
    "name": "crypto_box_new_seed",
    "language": "c",
    "definition": "pgsodium_crypto_box_new_seed",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_box_new_seed()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box_new_seed$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16710,
    "schema": "pgsodium",
    "name": "crypto_sign_new_seed",
    "language": "c",
    "definition": "pgsodium_crypto_sign_new_seed",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_new_seed()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_new_seed$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16719,
    "schema": "pgsodium",
    "name": "derive_key",
    "language": "c",
    "definition": "pgsodium_derive",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.derive_key(key_id bigint, key_len integer DEFAULT 32, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_derive$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "key_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_len",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "key_id bigint, key_len integer DEFAULT 32, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "key_id bigint, key_len integer, context bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16712,
    "schema": "pgsodium",
    "name": "pgsodium_derive",
    "language": "c",
    "definition": "pgsodium_derive",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.pgsodium_derive(key_id bigint, key_len integer DEFAULT 32, context bytea DEFAULT decode('pgsodium'::text, 'escape'::text))\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_derive$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "key_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_len",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "key_id bigint, key_len integer DEFAULT 32, context bytea DEFAULT decode('pgsodium'::text, 'escape'::text)",
    "identity_argument_types": "key_id bigint, key_len integer, context bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16696,
    "schema": "pgsodium",
    "name": "randombytes_new_seed",
    "language": "c",
    "definition": "pgsodium_randombytes_new_seed",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.randombytes_new_seed()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_randombytes_new_seed$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16650,
    "schema": "pgsodium",
    "name": "crypto_secretbox_keygen",
    "language": "c",
    "definition": "pgsodium_crypto_secretbox_keygen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_keygen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16656,
    "schema": "pgsodium",
    "name": "crypto_auth_keygen",
    "language": "c",
    "definition": "pgsodium_crypto_auth_keygen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_keygen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16663,
    "schema": "pgsodium",
    "name": "crypto_box_noncegen",
    "language": "c",
    "definition": "pgsodium_crypto_box_noncegen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_box_noncegen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box_noncegen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16726,
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_keygen",
    "language": "c",
    "definition": "pgsodium_crypto_aead_ietf_keygen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_keygen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16720,
    "schema": "pgsodium",
    "name": "crypto_shorthash_keygen",
    "language": "c",
    "definition": "pgsodium_crypto_shorthash_keygen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_shorthash_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_shorthash_keygen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16721,
    "schema": "pgsodium",
    "name": "crypto_generichash_keygen",
    "language": "c",
    "definition": "pgsodium_crypto_generichash_keygen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_generichash_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_generichash_keygen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16680,
    "schema": "pgsodium",
    "name": "crypto_kdf_keygen",
    "language": "c",
    "definition": "pgsodium_crypto_kdf_keygen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_kdf_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_kdf_keygen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16685,
    "schema": "pgsodium",
    "name": "crypto_kx_new_keypair",
    "language": "c",
    "definition": "pgsodium_crypto_kx_keypair",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_kx_new_keypair()\n RETURNS pgsodium.crypto_kx_keypair\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_kx_keypair$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 16684,
    "return_type": "pgsodium.crypto_kx_keypair",
    "return_type_relation_id": 16682,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16686,
    "schema": "pgsodium",
    "name": "crypto_kx_new_seed",
    "language": "c",
    "definition": "pgsodium_crypto_kx_new_seed",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_kx_new_seed()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_kx_new_seed$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16687,
    "schema": "pgsodium",
    "name": "crypto_kx_seed_new_keypair",
    "language": "c",
    "definition": "pgsodium_crypto_kx_seed_keypair",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_kx_seed_new_keypair(seed bytea)\n RETURNS pgsodium.crypto_kx_keypair\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/pgsodium', $function$pgsodium_crypto_kx_seed_keypair$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "seed",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "seed bytea",
    "identity_argument_types": "seed bytea",
    "return_type_id": 16684,
    "return_type": "pgsodium.crypto_kx_keypair",
    "return_type_relation_id": 16682,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16713,
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha256_keygen",
    "language": "c",
    "definition": "pgsodium_crypto_auth_hmacsha256_keygen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256_keygen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16706,
    "schema": "pgsodium",
    "name": "crypto_box_new_keypair",
    "language": "c",
    "definition": "pgsodium_crypto_box_keypair",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_box_new_keypair()\n RETURNS pgsodium.crypto_box_keypair\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box_keypair$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 16661,
    "return_type": "pgsodium.crypto_box_keypair",
    "return_type_relation_id": 16659,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16707,
    "schema": "pgsodium",
    "name": "crypto_sign_new_keypair",
    "language": "c",
    "definition": "pgsodium_crypto_sign_keypair",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_new_keypair()\n RETURNS pgsodium.crypto_sign_keypair\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_keypair$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 16668,
    "return_type": "pgsodium.crypto_sign_keypair",
    "return_type_relation_id": 16666,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16647,
    "schema": "pgsodium",
    "name": "randombytes_random",
    "language": "c",
    "definition": "pgsodium_randombytes_random",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.randombytes_random()\n RETURNS integer\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_randombytes_random$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 23,
    "return_type": "integer",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16651,
    "schema": "pgsodium",
    "name": "crypto_secretbox_noncegen",
    "language": "c",
    "definition": "pgsodium_crypto_secretbox_noncegen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_noncegen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_noncegen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16727,
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_noncegen",
    "language": "c",
    "definition": "pgsodium_crypto_aead_ietf_noncegen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_noncegen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_noncegen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16735,
    "schema": "pgsodium",
    "name": "crypto_secretstream_keygen",
    "language": "c",
    "definition": "pgsodium_crypto_secretstream_xchacha20poly1305_keygen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_secretstream_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_secretstream_xchacha20poly1305_keygen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16736,
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20_keygen",
    "language": "c",
    "definition": "pgsodium_crypto_stream_xchacha20_keygen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_keygen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16737,
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20_noncegen",
    "language": "c",
    "definition": "pgsodium_crypto_stream_xchacha20_noncegen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_noncegen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_noncegen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16744,
    "schema": "pgsodium",
    "name": "crypto_cmp",
    "language": "c",
    "definition": "pgsodium_cmp",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_cmp(text, text)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/pgsodium', $function$pgsodium_cmp$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "text, text",
    "identity_argument_types": "text, text",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16762,
    "schema": "pgsodium",
    "name": "crypto_signcrypt_new_keypair",
    "language": "c",
    "definition": "pgsodium_crypto_signcrypt_keypair",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_new_keypair()\n RETURNS pgsodium.crypto_signcrypt_keypair\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_keypair$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 16761,
    "return_type": "pgsodium.crypto_signcrypt_keypair",
    "return_type_relation_id": 16759,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16752,
    "schema": "pgsodium",
    "name": "crypto_aead_det_encrypt",
    "language": "c",
    "definition": "pgsodium_crypto_aead_det_encrypt",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_encrypt(message bytea, additional bytea, key bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_encrypt$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "message bytea, additional bytea, key bytea, nonce bytea DEFAULT NULL::bytea",
    "identity_argument_types": "message bytea, additional bytea, key bytea, nonce bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16753,
    "schema": "pgsodium",
    "name": "crypto_aead_det_decrypt",
    "language": "c",
    "definition": "pgsodium_crypto_aead_det_decrypt",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_decrypt(ciphertext bytea, additional bytea, key bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_decrypt$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "ciphertext",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "ciphertext bytea, additional bytea, key bytea, nonce bytea DEFAULT NULL::bytea",
    "identity_argument_types": "ciphertext bytea, additional bytea, key bytea, nonce bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16769,
    "schema": "pgsodium",
    "name": "sodium_base642bin",
    "language": "c",
    "definition": "pgsodium_sodium_base642bin",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.sodium_base642bin(base64 text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_sodium_base642bin$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "base64",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "base64 text",
    "identity_argument_types": "base64 text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16754,
    "schema": "pgsodium",
    "name": "crypto_aead_det_encrypt",
    "language": "c",
    "definition": "pgsodium_crypto_aead_det_encrypt_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_encrypt_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea",
    "identity_argument_types": "message bytea, additional bytea, key_id bigint, context bytea, nonce bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16755,
    "schema": "pgsodium",
    "name": "crypto_aead_det_decrypt",
    "language": "c",
    "definition": "pgsodium_crypto_aead_det_decrypt_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_decrypt_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea",
    "identity_argument_types": "message bytea, additional bytea, key_id bigint, context bytea, nonce bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16773,
    "schema": "pgsodium",
    "name": "version",
    "language": "sql",
    "definition": " SELECT extversion FROM pg_extension WHERE extname = 'pgsodium' ",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.version()\n RETURNS text\n LANGUAGE sql\nAS $function$ SELECT extversion FROM pg_extension WHERE extname = 'pgsodium' $function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16814,
    "schema": "pgsodium",
    "name": "crypto_aead_det_noncegen",
    "language": "c",
    "definition": "pgsodium_crypto_aead_det_noncegen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_noncegen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_noncegen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16826,
    "schema": "pgsodium",
    "name": "has_mask",
    "language": "sql",
    "definition": "\n  SELECT EXISTS(\n    SELECT 1\n      FROM pg_shseclabel\n     WHERE  objoid = role\n       AND provider = 'pgsodium'\n       AND label ilike 'ACCESS%' || source_name || '%')\n  ",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.has_mask(role regrole, source_name text)\n RETURNS boolean\n LANGUAGE sql\nAS $function$\n  SELECT EXISTS(\n    SELECT 1\n      FROM pg_shseclabel\n     WHERE  objoid = role\n       AND provider = 'pgsodium'\n       AND label ilike 'ACCESS%' || source_name || '%')\n  $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "role",
        "type_id": 4096,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "source_name",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "role regrole, source_name text",
    "identity_argument_types": "role regrole, source_name text",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16827,
    "schema": "pgsodium",
    "name": "mask_columns",
    "language": "sql",
    "definition": "\n  SELECT\n  a.attname,\n  m.key_id,\n  m.key_id_column,\n  m.associated_column,\n  m.nonce_column,\n  m.format_type\n  FROM pg_attribute a\n  LEFT JOIN  pgsodium.masking_rule m\n  ON m.attrelid = a.attrelid\n  AND m.attname = a.attname\n  WHERE  a.attrelid = source_relid\n  AND    a.attnum > 0 -- exclude ctid, cmin, cmax\n  AND    NOT a.attisdropped\n  ORDER BY a.attnum;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.mask_columns(source_relid oid)\n RETURNS TABLE(attname name, key_id text, key_id_column text, associated_column text, nonce_column text, format_type text)\n LANGUAGE sql\nAS $function$\n  SELECT\n  a.attname,\n  m.key_id,\n  m.key_id_column,\n  m.associated_column,\n  m.nonce_column,\n  m.format_type\n  FROM pg_attribute a\n  LEFT JOIN  pgsodium.masking_rule m\n  ON m.attrelid = a.attrelid\n  AND m.attname = a.attname\n  WHERE  a.attrelid = source_relid\n  AND    a.attnum > 0 -- exclude ctid, cmin, cmax\n  AND    NOT a.attisdropped\n  ORDER BY a.attnum;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "source_relid",
        "type_id": 26,
        "has_default": false
      },
      {
        "mode": "table",
        "name": "attname",
        "type_id": 19,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "key_id",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "key_id_column",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "associated_column",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "nonce_column",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "format_type",
        "type_id": 25,
        "has_default": null
      }
    ],
    "argument_types": "source_relid oid",
    "identity_argument_types": "source_relid oid",
    "return_type_id": 2249,
    "return_type": "TABLE(attname name, key_id text, key_id_column text, associated_column text, nonce_column text, format_type text)",
    "return_type_relation_id": null,
    "is_set_returning_function": true,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16830,
    "schema": "pgsodium",
    "name": "create_mask_view",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  body text;\n  source_name text;\n  view_name text;\n  rule pgsodium.masking_rule;\nBEGIN\n  SELECT DISTINCT(quote_ident(relname)) INTO STRICT view_name\n    FROM pg_class c, pg_seclabel sl\n   WHERE relid = c.oid\n     AND sl.classoid = c.tableoid\n     AND sl.objoid = c.oid;\n\n  source_name := relid::regclass;\n\n  body = format(\n    $c$\n    DROP VIEW IF EXISTS pgsodium_masks.%s;\n    CREATE VIEW pgsodium_masks.%s AS SELECT %s\n    FROM %s;\n    $c$,\n    view_name,\n    view_name,\n    pgsodium.decrypted_columns(relid),\n    source_name\n  );\n  IF debug THEN\n    RAISE NOTICE '%', body;\n  END IF;\n  EXECUTE body;\n\n  body = format(\n    $c$\n    CREATE OR REPLACE FUNCTION pgsodium_masks.%s_encrypt_secret()\n      RETURNS TRIGGER\n      LANGUAGE plpgsql\n      AS $t$\n    BEGIN\n    %s;\n    RETURN new;\n    END;\n    $t$;\n\n    DROP TRIGGER IF EXISTS %s_encrypt_secret_trigger ON %s;\n\n    CREATE TRIGGER %s_encrypt_secret_trigger\n      BEFORE INSERT ON %s\n      FOR EACH ROW\n      EXECUTE FUNCTION pgsodium_masks.%s_encrypt_secret ();\n    $c$,\n    view_name,\n    pgsodium.encrypted_columns(relid),\n    view_name,\n    source_name,\n    view_name,\n    source_name,\n    view_name\n  );\n  if debug THEN\n    RAISE NOTICE '%', body;\n  END IF;\n  EXECUTE body;\n\n  PERFORM pgsodium.mask_role(oid::regrole, source_name, view_name)\n  FROM pg_roles WHERE pgsodium.has_mask(oid::regrole, source_name);\n\n  RETURN;\nEND\n  ",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.create_mask_view(relid oid, debug boolean DEFAULT false)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog'\nAS $function$\nDECLARE\n  body text;\n  source_name text;\n  view_name text;\n  rule pgsodium.masking_rule;\nBEGIN\n  SELECT DISTINCT(quote_ident(relname)) INTO STRICT view_name\n    FROM pg_class c, pg_seclabel sl\n   WHERE relid = c.oid\n     AND sl.classoid = c.tableoid\n     AND sl.objoid = c.oid;\n\n  source_name := relid::regclass;\n\n  body = format(\n    $c$\n    DROP VIEW IF EXISTS pgsodium_masks.%s;\n    CREATE VIEW pgsodium_masks.%s AS SELECT %s\n    FROM %s;\n    $c$,\n    view_name,\n    view_name,\n    pgsodium.decrypted_columns(relid),\n    source_name\n  );\n  IF debug THEN\n    RAISE NOTICE '%', body;\n  END IF;\n  EXECUTE body;\n\n  body = format(\n    $c$\n    CREATE OR REPLACE FUNCTION pgsodium_masks.%s_encrypt_secret()\n      RETURNS TRIGGER\n      LANGUAGE plpgsql\n      AS $t$\n    BEGIN\n    %s;\n    RETURN new;\n    END;\n    $t$;\n\n    DROP TRIGGER IF EXISTS %s_encrypt_secret_trigger ON %s;\n\n    CREATE TRIGGER %s_encrypt_secret_trigger\n      BEFORE INSERT ON %s\n      FOR EACH ROW\n      EXECUTE FUNCTION pgsodium_masks.%s_encrypt_secret ();\n    $c$,\n    view_name,\n    pgsodium.encrypted_columns(relid),\n    view_name,\n    source_name,\n    view_name,\n    source_name,\n    view_name\n  );\n  if debug THEN\n    RAISE NOTICE '%', body;\n  END IF;\n  EXECUTE body;\n\n  PERFORM pgsodium.mask_role(oid::regrole, source_name, view_name)\n  FROM pg_roles WHERE pgsodium.has_mask(oid::regrole, source_name);\n\n  RETURN;\nEND\n  $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "relid",
        "type_id": 26,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "debug",
        "type_id": 16,
        "has_default": true
      }
    ],
    "argument_types": "relid oid, debug boolean DEFAULT false",
    "identity_argument_types": "relid oid, debug boolean",
    "return_type_id": 2278,
    "return_type": "void",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": {
      "search_path": "pg_catalog"
    }
  },
  {
    "id": 16898,
    "schema": "pgsodium",
    "name": "create_key",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  new_key pgsodium.key;\n  valid_key pgsodium.valid_key;\nBEGIN\n  INSERT INTO pgsodium.key (key_id, key_context, key_type, raw_key,\n  raw_key_nonce, parent_key, expires, name, associated_data)\n      VALUES (\n        CASE WHEN raw_key IS NULL THEN\n            NEXTVAL('pgsodium.key_key_id_seq'::REGCLASS)\n        ELSE NULL END,\n        CASE WHEN raw_key IS NULL THEN\n            key_context\n        ELSE NULL END,\n        key_type,\n        raw_key,\n        CASE WHEN raw_key IS NOT NULL THEN\n            COALESCE(raw_key_nonce, pgsodium.crypto_aead_det_noncegen())\n        ELSE NULL END,\n        CASE WHEN parent_key IS NULL and raw_key IS NOT NULL THEN\n            (pgsodium.create_key('aead-det')).id\n        ELSE parent_key END,\n        expires,\n        name,\n        associated_data)\n    RETURNING * INTO new_key;\n  SELECT * INTO valid_key FROM pgsodium.valid_key WHERE id = new_key.id;\n  RETURN valid_key;\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.create_key(key_type pgsodium.key_type DEFAULT 'aead-det'::pgsodium.key_type, name text DEFAULT NULL::text, raw_key bytea DEFAULT NULL::bytea, raw_key_nonce bytea DEFAULT NULL::bytea, parent_key uuid DEFAULT NULL::uuid, key_context bytea DEFAULT '\\x7067736f6469756d'::bytea, expires timestamp with time zone DEFAULT NULL::timestamp with time zone, associated_data text DEFAULT ''::text)\n RETURNS pgsodium.valid_key\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  new_key pgsodium.key;\n  valid_key pgsodium.valid_key;\nBEGIN\n  INSERT INTO pgsodium.key (key_id, key_context, key_type, raw_key,\n  raw_key_nonce, parent_key, expires, name, associated_data)\n      VALUES (\n        CASE WHEN raw_key IS NULL THEN\n            NEXTVAL('pgsodium.key_key_id_seq'::REGCLASS)\n        ELSE NULL END,\n        CASE WHEN raw_key IS NULL THEN\n            key_context\n        ELSE NULL END,\n        key_type,\n        raw_key,\n        CASE WHEN raw_key IS NOT NULL THEN\n            COALESCE(raw_key_nonce, pgsodium.crypto_aead_det_noncegen())\n        ELSE NULL END,\n        CASE WHEN parent_key IS NULL and raw_key IS NOT NULL THEN\n            (pgsodium.create_key('aead-det')).id\n        ELSE parent_key END,\n        expires,\n        name,\n        associated_data)\n    RETURNING * INTO new_key;\n  SELECT * INTO valid_key FROM pgsodium.valid_key WHERE id = new_key.id;\n  RETURN valid_key;\nEND;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "key_type",
        "type_id": 16784,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "name",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "raw_key",
        "type_id": 17,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "raw_key_nonce",
        "type_id": 17,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "parent_key",
        "type_id": 2950,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "key_context",
        "type_id": 17,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "expires",
        "type_id": 1184,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "associated_data",
        "type_id": 25,
        "has_default": true
      }
    ],
    "argument_types": "key_type pgsodium.key_type DEFAULT 'aead-det'::pgsodium.key_type, name text DEFAULT NULL::text, raw_key bytea DEFAULT NULL::bytea, raw_key_nonce bytea DEFAULT NULL::bytea, parent_key uuid DEFAULT NULL::uuid, key_context bytea DEFAULT '\\x7067736f6469756d'::bytea, expires timestamp with time zone DEFAULT NULL::timestamp with time zone, associated_data text DEFAULT ''::text",
    "identity_argument_types": "key_type pgsodium.key_type, name text, raw_key bytea, raw_key_nonce bytea, parent_key uuid, key_context bytea, expires timestamp with time zone, associated_data text",
    "return_type_id": 16896,
    "return_type": "pgsodium.valid_key",
    "return_type_relation_id": 16894,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16658,
    "schema": "pgsodium",
    "name": "crypto_shorthash",
    "language": "c",
    "definition": "pgsodium_crypto_shorthash",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_shorthash(message bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_shorthash$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, key bytea",
    "identity_argument_types": "message bytea, key bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16676,
    "schema": "pgsodium",
    "name": "crypto_pwhash_str",
    "language": "c",
    "definition": "pgsodium_crypto_pwhash_str",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_pwhash_str(password bytea)\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_pwhash_str$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "password",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "password bytea",
    "identity_argument_types": "password bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16920,
    "schema": "pgsodium",
    "name": "quote_assoc",
    "language": "sql",
    "definition": "\n    WITH a AS (SELECT array_agg(CASE WHEN $2 THEN\n                                    'new.' || quote_ident(trim(v))\n                                ELSE quote_ident(trim(v)) END) as r\n               FROM regexp_split_to_table($1, '\\s*,\\s*') as v)\n    SELECT array_to_string(a.r, '::text || ') || '::text' FROM a;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.quote_assoc(text, boolean DEFAULT false)\n RETURNS text\n LANGUAGE sql\nAS $function$\n    WITH a AS (SELECT array_agg(CASE WHEN $2 THEN\n                                    'new.' || quote_ident(trim(v))\n                                ELSE quote_ident(trim(v)) END) as r\n               FROM regexp_split_to_table($1, '\\s*,\\s*') as v)\n    SELECT array_to_string(a.r, '::text || ') || '::text' FROM a;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": true
      }
    ],
    "argument_types": "text, boolean DEFAULT false",
    "identity_argument_types": "text, boolean",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16677,
    "schema": "pgsodium",
    "name": "crypto_pwhash_str_verify",
    "language": "c",
    "definition": "pgsodium_crypto_pwhash_str_verify",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_pwhash_str_verify(hashed_password bytea, password bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_pwhash_str_verify$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "hashed_password",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "password",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "hashed_password bytea, password bytea",
    "identity_argument_types": "hashed_password bytea, password bytea",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16648,
    "schema": "pgsodium",
    "name": "randombytes_uniform",
    "language": "c",
    "definition": "pgsodium_randombytes_uniform",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.randombytes_uniform(upper_bound integer)\n RETURNS integer\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_randombytes_uniform$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "upper_bound",
        "type_id": 23,
        "has_default": false
      }
    ],
    "argument_types": "upper_bound integer",
    "identity_argument_types": "upper_bound integer",
    "return_type_id": 23,
    "return_type": "integer",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16907,
    "schema": "pgsodium",
    "name": "crypto_kdf_derive_from_key",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = primary_key AND key_type = 'kdf';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_kdf_derive_from_key(subkey_size, subkey_id, context, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.derive_key(key.key_id, subkey_size, key.key_context);\nEND;\n\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_kdf_derive_from_key(subkey_size integer, subkey_id bigint, context bytea, primary_key uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE STRICT SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = primary_key AND key_type = 'kdf';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_kdf_derive_from_key(subkey_size, subkey_id, context, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.derive_key(key.key_id, subkey_size, key.key_context);\nEND;\n\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "subkey_size",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "subkey_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "primary_key",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "subkey_size integer, subkey_id bigint, context bytea, primary_key uuid",
    "identity_argument_types": "subkey_size integer, subkey_id bigint, context bytea, primary_key uuid",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16649,
    "schema": "pgsodium",
    "name": "randombytes_buf",
    "language": "c",
    "definition": "pgsodium_randombytes_buf",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.randombytes_buf(size integer)\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_randombytes_buf$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "size",
        "type_id": 23,
        "has_default": false
      }
    ],
    "argument_types": "size integer",
    "identity_argument_types": "size integer",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16815,
    "schema": "pgsodium",
    "name": "crypto_aead_det_encrypt",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.key_id, key.key_context);\nEND;\n  ",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_encrypt(message bytea, additional bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.key_id, key.key_context);\nEND;\n  $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, additional bytea, key_uuid uuid",
    "identity_argument_types": "message bytea, additional bytea, key_uuid uuid",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16816,
    "schema": "pgsodium",
    "name": "crypto_aead_det_decrypt",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.key_id, key.key_context);\nEND;\n  ",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_decrypt(message bytea, additional bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.key_id, key.key_context);\nEND;\n  $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, additional bytea, key_uuid uuid",
    "identity_argument_types": "message bytea, additional bytea, key_uuid uuid",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16697,
    "schema": "pgsodium",
    "name": "randombytes_buf_deterministic",
    "language": "c",
    "definition": "pgsodium_randombytes_buf_deterministic",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.randombytes_buf_deterministic(size integer, seed bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_randombytes_buf_deterministic$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "size",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "seed",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "size integer, seed bytea",
    "identity_argument_types": "size integer, seed bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16930,
    "schema": "pgsodium",
    "name": "get_key_by_id",
    "language": "sql",
    "definition": "\n    SELECT * from pgsodium.valid_key WHERE id = $1;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.get_key_by_id(uuid)\n RETURNS pgsodium.valid_key\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\n    SELECT * from pgsodium.valid_key WHERE id = $1;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "uuid",
    "identity_argument_types": "uuid",
    "return_type_id": 16896,
    "return_type": "pgsodium.valid_key",
    "return_type_relation_id": 16894,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16931,
    "schema": "pgsodium",
    "name": "get_key_by_name",
    "language": "sql",
    "definition": "\n    SELECT * from pgsodium.valid_key WHERE name = $1;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.get_key_by_name(text)\n RETURNS pgsodium.valid_key\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\n    SELECT * from pgsodium.valid_key WHERE name = $1;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "text",
    "identity_argument_types": "text",
    "return_type_id": 16896,
    "return_type": "pgsodium.valid_key",
    "return_type_relation_id": 16894,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16932,
    "schema": "pgsodium",
    "name": "get_named_keys",
    "language": "sql",
    "definition": "\n    SELECT * from pgsodium.valid_key vk WHERE vk.name ILIKE filter;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.get_named_keys(filter text DEFAULT '%'::text)\n RETURNS SETOF pgsodium.valid_key\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\n    SELECT * from pgsodium.valid_key vk WHERE vk.name ILIKE filter;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "filter",
        "type_id": 25,
        "has_default": true
      }
    ],
    "argument_types": "filter text DEFAULT '%'::text",
    "identity_argument_types": "filter text",
    "return_type_id": 16896,
    "return_type": "SETOF pgsodium.valid_key",
    "return_type_relation_id": 16894,
    "is_set_returning_function": true,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16934,
    "schema": "pgsodium",
    "name": "enable_security_label_trigger",
    "language": "sql",
    "definition": "\n    ALTER EVENT TRIGGER pgsodium_trg_mask_update ENABLE;\n  ",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.enable_security_label_trigger()\n RETURNS void\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\n    ALTER EVENT TRIGGER pgsodium_trg_mask_update ENABLE;\n  $function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2278,
    "return_type": "void",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16935,
    "schema": "pgsodium",
    "name": "disable_security_label_trigger",
    "language": "sql",
    "definition": "\n    ALTER EVENT TRIGGER pgsodium_trg_mask_update DISABLE;\n  ",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.disable_security_label_trigger()\n RETURNS void\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\n    ALTER EVENT TRIGGER pgsodium_trg_mask_update DISABLE;\n  $function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2278,
    "return_type": "void",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16936,
    "schema": "pgsodium",
    "name": "update_mask",
    "language": "plpgsql",
    "definition": "\nBEGIN\n  PERFORM pgsodium.disable_security_label_trigger();\n  PERFORM pgsodium.create_mask_view(objoid, objsubid, debug)\n    FROM pg_catalog.pg_seclabel sl\n    WHERE sl.objoid = target\n      AND sl.label ILIKE 'ENCRYPT%'\n      AND sl.provider = 'pgsodium';\n  PERFORM pgsodium.enable_security_label_trigger();\n  RETURN;\nEND\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.update_mask(target oid, debug boolean DEFAULT false)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  PERFORM pgsodium.disable_security_label_trigger();\n  PERFORM pgsodium.create_mask_view(objoid, objsubid, debug)\n    FROM pg_catalog.pg_seclabel sl\n    WHERE sl.objoid = target\n      AND sl.label ILIKE 'ENCRYPT%'\n      AND sl.provider = 'pgsodium';\n  PERFORM pgsodium.enable_security_label_trigger();\n  RETURN;\nEND\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "target",
        "type_id": 26,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "debug",
        "type_id": 16,
        "has_default": true
      }
    ],
    "argument_types": "target oid, debug boolean DEFAULT false",
    "identity_argument_types": "target oid, debug boolean",
    "return_type_id": 2278,
    "return_type": "void",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16702,
    "schema": "pgsodium",
    "name": "crypto_sign_update_agg1",
    "language": "sql",
    "definition": "\n SELECT pgsodium.crypto_sign_update(COALESCE(state, pgsodium.crypto_sign_init()), message);\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_update_agg1(state bytea, message bytea)\n RETURNS bytea\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n SELECT pgsodium.crypto_sign_update(COALESCE(state, pgsodium.crypto_sign_init()), message);\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "state",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "state bytea, message bytea",
    "identity_argument_types": "state bytea, message bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16703,
    "schema": "pgsodium",
    "name": "crypto_sign_update_agg2",
    "language": "sql",
    "definition": "\n SELECT pgsodium.crypto_sign_update(\n       COALESCE(cur_state, initial_state),\n\t   message)\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_update_agg2(cur_state bytea, initial_state bytea, message bytea)\n RETURNS bytea\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n SELECT pgsodium.crypto_sign_update(\n       COALESCE(cur_state, initial_state),\n\t   message)\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "cur_state",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "initial_state",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "cur_state bytea, initial_state bytea, message bytea",
    "identity_argument_types": "cur_state bytea, initial_state bytea, message bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16829,
    "schema": "pgsodium",
    "name": "encrypted_columns",
    "language": "plpgsql",
    "definition": "\nDECLARE\n    m RECORD;\n    expression TEXT;\n    comma TEXT;\nBEGIN\n  expression := '';\n  comma := E'        ';\n  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP\n    IF m.key_id IS NULL AND m.key_id_column is NULL THEN\n      CONTINUE;\n    ELSE\n      expression := expression || comma;\n      IF m.format_type = 'text' THEN\n          expression := expression || format(\n            $f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.encode(\n                  pgsodium.crypto_aead_det_encrypt(\n                    pg_catalog.convert_to(%s, 'utf8'),\n                    pg_catalog.convert_to((%s)::text, 'utf8'),\n                    %s::uuid,\n                    %s\n                  ),\n                    'base64') END END$f$,\n                'new.' || quote_ident(m.attname),\n                'new.' || quote_ident(m.attname),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                'new.' || quote_ident(m.attname),\n                COALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                COALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n          );\n      ELSIF m.format_type = 'bytea' THEN\n          expression := expression || format(\n            $f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE\n                        pgsodium.crypto_aead_det_encrypt(%s::bytea, pg_catalog.convert_to((%s)::text, 'utf8'),\n                %s::uuid,\n                %s\n              ) END END$f$,\n                'new.' || quote_ident(m.attname),\n                'new.' || quote_ident(m.attname),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                'new.' || quote_ident(m.attname),\n                COALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                COALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n          );\n      END IF;\n    END IF;\n    comma := E';\\n        ';\n  END LOOP;\n  RETURN expression;\nEND\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.encrypted_columns(relid oid)\n RETURNS text\n LANGUAGE plpgsql\n SET search_path TO ''\nAS $function$\nDECLARE\n    m RECORD;\n    expression TEXT;\n    comma TEXT;\nBEGIN\n  expression := '';\n  comma := E'        ';\n  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP\n    IF m.key_id IS NULL AND m.key_id_column is NULL THEN\n      CONTINUE;\n    ELSE\n      expression := expression || comma;\n      IF m.format_type = 'text' THEN\n          expression := expression || format(\n            $f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.encode(\n                  pgsodium.crypto_aead_det_encrypt(\n                    pg_catalog.convert_to(%s, 'utf8'),\n                    pg_catalog.convert_to((%s)::text, 'utf8'),\n                    %s::uuid,\n                    %s\n                  ),\n                    'base64') END END$f$,\n                'new.' || quote_ident(m.attname),\n                'new.' || quote_ident(m.attname),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                'new.' || quote_ident(m.attname),\n                COALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                COALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n          );\n      ELSIF m.format_type = 'bytea' THEN\n          expression := expression || format(\n            $f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE\n                        pgsodium.crypto_aead_det_encrypt(%s::bytea, pg_catalog.convert_to((%s)::text, 'utf8'),\n                %s::uuid,\n                %s\n              ) END END$f$,\n                'new.' || quote_ident(m.attname),\n                'new.' || quote_ident(m.attname),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                'new.' || quote_ident(m.attname),\n                COALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                COALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n          );\n      END IF;\n    END IF;\n    comma := E';\\n        ';\n  END LOOP;\n  RETURN expression;\nEND\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "relid",
        "type_id": 26,
        "has_default": false
      }
    ],
    "argument_types": "relid oid",
    "identity_argument_types": "relid oid",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16828,
    "schema": "pgsodium",
    "name": "decrypted_columns",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  m RECORD;\n  expression TEXT;\n  comma TEXT;\n  padding text = '        ';\nBEGIN\n  expression := E'\\n';\n  comma := padding;\n  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP\n    expression := expression || comma;\n    IF m.key_id IS NULL AND m.key_id_column IS NULL THEN\n      expression := expression || padding || quote_ident(m.attname);\n    ELSE\n      expression := expression || padding || quote_ident(m.attname) || E',\\n';\n      IF m.format_type = 'text' THEN\n          expression := expression || format(\n            $f$\n            CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.convert_from(\n                  pgsodium.crypto_aead_det_decrypt(\n                    pg_catalog.decode(%s, 'base64'),\n                    pg_catalog.convert_to((%s)::text, 'utf8'),\n                    %s::uuid,\n                    %s\n                  ),\n                    'utf8') END\n                END AS %s$f$,\n                quote_ident(m.attname),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                quote_ident(m.attname),\n                coalesce(pgsodium.quote_assoc(m.associated_columns), quote_literal('')),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                coalesce(quote_ident(m.nonce_column), 'NULL'),\n                quote_ident('decrypted_' || m.attname)\n          );\n      ELSIF m.format_type = 'bytea' THEN\n          expression := expression || format(\n            $f$\n            CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE pgsodium.crypto_aead_det_decrypt(\n                    %s::bytea,\n                    pg_catalog.convert_to((%s)::text, 'utf8'),\n                    %s::uuid,\n                    %s\n                  ) END\n                END AS %s$f$,\n                quote_ident(m.attname),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                quote_ident(m.attname),\n                coalesce(pgsodium.quote_assoc(m.associated_columns), quote_literal('')),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                coalesce(quote_ident(m.nonce_column), 'NULL'),\n                'decrypted_' || quote_ident(m.attname)\n          );\n      END IF;\n    END IF;\n    comma := E',       \\n';\n  END LOOP;\n  RETURN expression;\nEND\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.decrypted_columns(relid oid)\n RETURNS text\n LANGUAGE plpgsql\n SET search_path TO ''\nAS $function$\nDECLARE\n  m RECORD;\n  expression TEXT;\n  comma TEXT;\n  padding text = '        ';\nBEGIN\n  expression := E'\\n';\n  comma := padding;\n  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP\n    expression := expression || comma;\n    IF m.key_id IS NULL AND m.key_id_column IS NULL THEN\n      expression := expression || padding || quote_ident(m.attname);\n    ELSE\n      expression := expression || padding || quote_ident(m.attname) || E',\\n';\n      IF m.format_type = 'text' THEN\n          expression := expression || format(\n            $f$\n            CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.convert_from(\n                  pgsodium.crypto_aead_det_decrypt(\n                    pg_catalog.decode(%s, 'base64'),\n                    pg_catalog.convert_to((%s)::text, 'utf8'),\n                    %s::uuid,\n                    %s\n                  ),\n                    'utf8') END\n                END AS %s$f$,\n                quote_ident(m.attname),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                quote_ident(m.attname),\n                coalesce(pgsodium.quote_assoc(m.associated_columns), quote_literal('')),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                coalesce(quote_ident(m.nonce_column), 'NULL'),\n                quote_ident('decrypted_' || m.attname)\n          );\n      ELSIF m.format_type = 'bytea' THEN\n          expression := expression || format(\n            $f$\n            CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE pgsodium.crypto_aead_det_decrypt(\n                    %s::bytea,\n                    pg_catalog.convert_to((%s)::text, 'utf8'),\n                    %s::uuid,\n                    %s\n                  ) END\n                END AS %s$f$,\n                quote_ident(m.attname),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                quote_ident(m.attname),\n                coalesce(pgsodium.quote_assoc(m.associated_columns), quote_literal('')),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                coalesce(quote_ident(m.nonce_column), 'NULL'),\n                'decrypted_' || quote_ident(m.attname)\n          );\n      END IF;\n    END IF;\n    comma := E',       \\n';\n  END LOOP;\n  RETURN expression;\nEND\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "relid",
        "type_id": 26,
        "has_default": false
      }
    ],
    "argument_types": "relid oid",
    "identity_argument_types": "relid oid",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16728,
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_encrypt",
    "language": "c",
    "definition": "pgsodium_crypto_aead_ietf_encrypt",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_encrypt(message bytea, additional bytea, nonce bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_encrypt$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, additional bytea, nonce bytea, key bytea",
    "identity_argument_types": "message bytea, additional bytea, nonce bytea, key bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16730,
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_encrypt",
    "language": "c",
    "definition": "pgsodium_crypto_aead_ietf_encrypt_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_encrypt(message bytea, additional bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_encrypt_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "message bytea, additional bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "message bytea, additional bytea, nonce bytea, key_id bigint, context bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16819,
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_encrypt",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-ietf';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_ietf_encrypt(message, additional, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_ietf_encrypt(message, additional, nonce, key.key_id, key.key_context);\nEND;\n  ",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_encrypt(message bytea, additional bytea, nonce bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-ietf';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_ietf_encrypt(message, additional, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_ietf_encrypt(message, additional, nonce, key.key_id, key.key_context);\nEND;\n  $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, additional bytea, nonce bytea, key_uuid uuid",
    "identity_argument_types": "message bytea, additional bytea, nonce bytea, key_uuid uuid",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16729,
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_decrypt",
    "language": "c",
    "definition": "pgsodium_crypto_aead_ietf_decrypt",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_decrypt(message bytea, additional bytea, nonce bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_decrypt$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, additional bytea, nonce bytea, key bytea",
    "identity_argument_types": "message bytea, additional bytea, nonce bytea, key bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16731,
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_decrypt",
    "language": "c",
    "definition": "pgsodium_crypto_aead_ietf_decrypt_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_decrypt(message bytea, additional bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_decrypt_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "message bytea, additional bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "message bytea, additional bytea, nonce bytea, key_id bigint, context bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16820,
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_decrypt",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-ietf';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_ietf_decrypt(message, additional, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_ietf_decrypt(message, additional, nonce, key.key_id, key.key_context);\nEND;\n  ",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_decrypt(message bytea, additional bytea, nonce bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-ietf';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_ietf_decrypt(message, additional, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_ietf_decrypt(message, additional, nonce, key.key_id, key.key_context);\nEND;\n  $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, additional bytea, nonce bytea, key_uuid uuid",
    "identity_argument_types": "message bytea, additional bytea, nonce bytea, key_uuid uuid",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16654,
    "schema": "pgsodium",
    "name": "crypto_auth",
    "language": "c",
    "definition": "pgsodium_crypto_auth",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth(message bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, key bytea",
    "identity_argument_types": "message bytea, key bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16724,
    "schema": "pgsodium",
    "name": "crypto_auth",
    "language": "c",
    "definition": "pgsodium_crypto_auth_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth(message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "message bytea, key_id bigint, context bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16903,
    "schema": "pgsodium",
    "name": "crypto_auth",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'auth';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth(message, key.key_id, key.key_context);\nEND;\n\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth(message bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'auth';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth(message, key.key_id, key.key_context);\nEND;\n\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, key_uuid uuid",
    "identity_argument_types": "message bytea, key_uuid uuid",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16655,
    "schema": "pgsodium",
    "name": "crypto_auth_verify",
    "language": "c",
    "definition": "pgsodium_crypto_auth_verify",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_verify(mac bytea, message bytea, key bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_verify$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "mac",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "mac bytea, message bytea, key bytea",
    "identity_argument_types": "mac bytea, message bytea, key bytea",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16725,
    "schema": "pgsodium",
    "name": "crypto_auth_verify",
    "language": "c",
    "definition": "pgsodium_crypto_auth_verify_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_verify(mac bytea, message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_verify_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "mac",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "mac bytea, message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "mac bytea, message bytea, key_id bigint, context bytea",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16904,
    "schema": "pgsodium",
    "name": "crypto_auth_verify",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'auth';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_verify(mac, message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_verify(mac, message, key.key_id, key.key_context);\nEND;\n\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_verify(mac bytea, message bytea, key_uuid uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'auth';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_verify(mac, message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_verify(mac, message, key.key_id, key.key_context);\nEND;\n\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "mac",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "mac bytea, message bytea, key_uuid uuid",
    "identity_argument_types": "mac bytea, message bytea, key_uuid uuid",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16709,
    "schema": "pgsodium",
    "name": "crypto_box_seed_new_keypair",
    "language": "c",
    "definition": "pgsodium_crypto_box_seed_keypair",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_box_seed_new_keypair(seed bytea)\n RETURNS pgsodium.crypto_box_keypair\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box_seed_keypair$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "seed",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "seed bytea",
    "identity_argument_types": "seed bytea",
    "return_type_id": 16661,
    "return_type": "pgsodium.crypto_box_keypair",
    "return_type_relation_id": 16659,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16664,
    "schema": "pgsodium",
    "name": "crypto_box",
    "language": "c",
    "definition": "pgsodium_crypto_box",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_box(message bytea, nonce bytea, public bytea, secret bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "public",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "secret",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, nonce bytea, public bytea, secret bytea",
    "identity_argument_types": "message bytea, nonce bytea, public bytea, secret bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16665,
    "schema": "pgsodium",
    "name": "crypto_box_open",
    "language": "c",
    "definition": "pgsodium_crypto_box_open",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_box_open(ciphertext bytea, nonce bytea, public bytea, secret bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box_open$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "ciphertext",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "public",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "secret",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "ciphertext bytea, nonce bytea, public bytea, secret bytea",
    "identity_argument_types": "ciphertext bytea, nonce bytea, public bytea, secret bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16678,
    "schema": "pgsodium",
    "name": "crypto_box_seal",
    "language": "c",
    "definition": "pgsodium_crypto_box_seal",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_box_seal(message bytea, public_key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box_seal$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "public_key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, public_key bytea",
    "identity_argument_types": "message bytea, public_key bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16679,
    "schema": "pgsodium",
    "name": "crypto_box_seal_open",
    "language": "c",
    "definition": "pgsodium_crypto_box_seal_open",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_box_seal_open(ciphertext bytea, public_key bytea, secret_key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box_seal_open$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "ciphertext",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "public_key",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "secret_key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "ciphertext bytea, public_key bytea, secret_key bytea",
    "identity_argument_types": "ciphertext bytea, public_key bytea, secret_key bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16745,
    "schema": "pgsodium",
    "name": "crypto_generichash",
    "language": "c",
    "definition": "pgsodium_crypto_generichash_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_generichash(message bytea, key bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_generichash_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "message bytea, key bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "message bytea, key bigint, context bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16657,
    "schema": "pgsodium",
    "name": "crypto_generichash",
    "language": "c",
    "definition": "pgsodium_crypto_generichash",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_generichash(message bytea, key bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_generichash$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "message bytea, key bytea DEFAULT NULL::bytea",
    "identity_argument_types": "message bytea, key bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16906,
    "schema": "pgsodium",
    "name": "crypto_generichash",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'generichash';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_generichash(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_generichash(message, key.key_id, key.key_context);\nEND;\n\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_generichash(message bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'generichash';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_generichash(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_generichash(message, key.key_id, key.key_context);\nEND;\n\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, key_uuid uuid",
    "identity_argument_types": "message bytea, key_uuid uuid",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16746,
    "schema": "pgsodium",
    "name": "crypto_shorthash",
    "language": "c",
    "definition": "pgsodium_crypto_shorthash_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_shorthash(message bytea, key bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_shorthash_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "message bytea, key bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "message bytea, key bigint, context bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16905,
    "schema": "pgsodium",
    "name": "crypto_shorthash",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'shorthash';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_shorthash(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_shorthash(message, key.key_id, key.key_context);\nEND;\n\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_shorthash(message bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'shorthash';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_shorthash(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_shorthash(message, key.key_id, key.key_context);\nEND;\n\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, key_uuid uuid",
    "identity_argument_types": "message bytea, key_uuid uuid",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16768,
    "schema": "pgsodium",
    "name": "sodium_bin2base64",
    "language": "c",
    "definition": "pgsodium_sodium_bin2base64",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.sodium_bin2base64(bin bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_sodium_bin2base64$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "bin",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "bin bytea",
    "identity_argument_types": "bin bytea",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16694,
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha512",
    "language": "c",
    "definition": "pgsodium_crypto_auth_hmacsha512",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512(message bytea, secret bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "secret",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, secret bytea",
    "identity_argument_types": "message bytea, secret bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16747,
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha512",
    "language": "c",
    "definition": "pgsodium_crypto_auth_hmacsha512_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512(message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "message bytea, key_id bigint, context bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16901,
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha512",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha512';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha512(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha512(message, key.key_id, key.key_context);\nEND;\n\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512(message bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha512';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha512(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha512(message, key.key_id, key.key_context);\nEND;\n\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, key_uuid uuid",
    "identity_argument_types": "message bytea, key_uuid uuid",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16695,
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha512_verify",
    "language": "c",
    "definition": "pgsodium_crypto_auth_hmacsha512_verify",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512_verify(hash bytea, message bytea, secret bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512_verify$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "hash",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "secret",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "hash bytea, message bytea, secret bytea",
    "identity_argument_types": "hash bytea, message bytea, secret bytea",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16748,
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha512_verify",
    "language": "c",
    "definition": "pgsodium_crypto_auth_hmacsha512_verify_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512_verify(hash bytea, message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512_verify_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "hash",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "hash bytea, message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "hash bytea, message bytea, key_id bigint, context bytea",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16902,
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha512_verify",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha512';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha512_verify(signature, message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha512_verify(signature, message, key.key_id, key.key_context);\nEND;\n\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512_verify(signature bytea, message bytea, key_uuid uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha512';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha512_verify(signature, message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha512_verify(signature, message, key.key_id, key.key_context);\nEND;\n\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "signature",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "signature bytea, message bytea, key_uuid uuid",
    "identity_argument_types": "signature bytea, message bytea, key_uuid uuid",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16714,
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha256",
    "language": "c",
    "definition": "pgsodium_crypto_auth_hmacsha256",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256(message bytea, secret bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "secret",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, secret bytea",
    "identity_argument_types": "message bytea, secret bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16749,
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha256",
    "language": "c",
    "definition": "pgsodium_crypto_auth_hmacsha256_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256(message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "message bytea, key_id bigint, context bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16899,
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha256",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha256';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha256(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha256(message, key.key_id, key.key_context);\nEND;\n\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256(message bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha256';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha256(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha256(message, key.key_id, key.key_context);\nEND;\n\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, key_uuid uuid",
    "identity_argument_types": "message bytea, key_uuid uuid",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16715,
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha256_verify",
    "language": "c",
    "definition": "pgsodium_crypto_auth_hmacsha256_verify",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256_verify(hash bytea, message bytea, secret bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256_verify$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "hash",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "secret",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "hash bytea, message bytea, secret bytea",
    "identity_argument_types": "hash bytea, message bytea, secret bytea",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16750,
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha256_verify",
    "language": "c",
    "definition": "pgsodium_crypto_auth_hmacsha256_verify_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256_verify(hash bytea, message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256_verify_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "hash",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "hash bytea, message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "hash bytea, message bytea, key_id bigint, context bytea",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16900,
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha256_verify",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha256';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha256_verify(signature, message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha256_verify(signature, message, key.key_id, key.key_context);\nEND;\n\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256_verify(signature bytea, message bytea, key_uuid uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha256';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha256_verify(signature, message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha256_verify(signature, message, key.key_id, key.key_context);\nEND;\n\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "signature",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "signature bytea, message bytea, key_uuid uuid",
    "identity_argument_types": "signature bytea, message bytea, key_uuid uuid",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16718,
    "schema": "pgsodium",
    "name": "crypto_kdf_derive_from_key",
    "language": "c",
    "definition": "pgsodium_crypto_kdf_derive_from_key",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_kdf_derive_from_key(subkey_size bigint, subkey_id bigint, context bytea, primary_key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_kdf_derive_from_key$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "subkey_size",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "subkey_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "primary_key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "subkey_size bigint, subkey_id bigint, context bytea, primary_key bytea",
    "identity_argument_types": "subkey_size bigint, subkey_id bigint, context bytea, primary_key bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16675,
    "schema": "pgsodium",
    "name": "crypto_pwhash",
    "language": "c",
    "definition": "pgsodium_crypto_pwhash",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_pwhash(password bytea, salt bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_pwhash$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "password",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "salt",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "password bytea, salt bytea",
    "identity_argument_types": "password bytea, salt bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16652,
    "schema": "pgsodium",
    "name": "crypto_secretbox",
    "language": "c",
    "definition": "pgsodium_crypto_secretbox",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox(message bytea, nonce bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, nonce bytea, key bytea",
    "identity_argument_types": "message bytea, nonce bytea, key bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16722,
    "schema": "pgsodium",
    "name": "crypto_secretbox",
    "language": "c",
    "definition": "pgsodium_crypto_secretbox_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox(message bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "message bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "message bytea, nonce bytea, key_id bigint, context bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16908,
    "schema": "pgsodium",
    "name": "crypto_secretbox",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'secretbox';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_secretbox(message, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_secretbox(message, nonce, key.key_id, key.key_context);\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox(message bytea, nonce bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'secretbox';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_secretbox(message, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_secretbox(message, nonce, key.key_id, key.key_context);\nEND;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, nonce bytea, key_uuid uuid",
    "identity_argument_types": "message bytea, nonce bytea, key_uuid uuid",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16653,
    "schema": "pgsodium",
    "name": "crypto_secretbox_open",
    "language": "c",
    "definition": "pgsodium_crypto_secretbox_open",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_open(ciphertext bytea, nonce bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_open$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "ciphertext",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "ciphertext bytea, nonce bytea, key bytea",
    "identity_argument_types": "ciphertext bytea, nonce bytea, key bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16723,
    "schema": "pgsodium",
    "name": "crypto_secretbox_open",
    "language": "c",
    "definition": "pgsodium_crypto_secretbox_open_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_open(message bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_open_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "message bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "message bytea, nonce bytea, key_id bigint, context bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16909,
    "schema": "pgsodium",
    "name": "crypto_secretbox_open",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'secretbox';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_secretbox_open(message, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_secretbox_open(message, nonce, key.key_id, key.key_context);\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_open(message bytea, nonce bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'secretbox';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_secretbox_open(message, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_secretbox_open(message, nonce, key.key_id, key.key_context);\nEND;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, nonce bytea, key_uuid uuid",
    "identity_argument_types": "message bytea, nonce bytea, key_uuid uuid",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16716,
    "schema": "pgsodium",
    "name": "crypto_hash_sha256",
    "language": "c",
    "definition": "pgsodium_crypto_hash_sha256",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_hash_sha256(message bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_hash_sha256$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea",
    "identity_argument_types": "message bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16717,
    "schema": "pgsodium",
    "name": "crypto_hash_sha512",
    "language": "c",
    "definition": "pgsodium_crypto_hash_sha512",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_hash_sha512(message bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_hash_sha512$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea",
    "identity_argument_types": "message bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16670,
    "schema": "pgsodium",
    "name": "crypto_sign",
    "language": "c",
    "definition": "pgsodium_crypto_sign",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_sign(message bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, key bytea",
    "identity_argument_types": "message bytea, key bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16672,
    "schema": "pgsodium",
    "name": "crypto_sign_detached",
    "language": "c",
    "definition": "pgsodium_crypto_sign_detached",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_detached(message bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_detached$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, key bytea",
    "identity_argument_types": "message bytea, key bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16700,
    "schema": "pgsodium",
    "name": "crypto_sign_final_create",
    "language": "c",
    "definition": "pgsodium_crypto_sign_final_create",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_final_create(state bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_final_create$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "state",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "state bytea, key bytea",
    "identity_argument_types": "state bytea, key bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16701,
    "schema": "pgsodium",
    "name": "crypto_sign_final_verify",
    "language": "c",
    "definition": "pgsodium_crypto_sign_final_verify",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_final_verify(state bytea, signature bytea, key bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_final_verify$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "state",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "signature",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "state bytea, signature bytea, key bytea",
    "identity_argument_types": "state bytea, signature bytea, key bytea",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16671,
    "schema": "pgsodium",
    "name": "crypto_sign_open",
    "language": "c",
    "definition": "pgsodium_crypto_sign_open",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_open(signed_message bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_open$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "signed_message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "signed_message bytea, key bytea",
    "identity_argument_types": "signed_message bytea, key bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16711,
    "schema": "pgsodium",
    "name": "crypto_sign_seed_new_keypair",
    "language": "c",
    "definition": "pgsodium_crypto_sign_seed_keypair",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_seed_new_keypair(seed bytea)\n RETURNS pgsodium.crypto_sign_keypair\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_seed_keypair$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "seed",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "seed bytea",
    "identity_argument_types": "seed bytea",
    "return_type_id": 16668,
    "return_type": "pgsodium.crypto_sign_keypair",
    "return_type_relation_id": 16666,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16673,
    "schema": "pgsodium",
    "name": "crypto_sign_verify_detached",
    "language": "c",
    "definition": "pgsodium_crypto_sign_verify_detached",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_verify_detached(sig bytea, message bytea, key bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_verify_detached$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "sig",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "sig bytea, message bytea, key bytea",
    "identity_argument_types": "sig bytea, message bytea, key bytea",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16764,
    "schema": "pgsodium",
    "name": "crypto_signcrypt_sign_after",
    "language": "c",
    "definition": "pgsodium_crypto_signcrypt_sign_after",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_sign_after(state bytea, sender_sk bytea, ciphertext bytea)\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_sign_after$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "state",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "sender_sk",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "ciphertext",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "state bytea, sender_sk bytea, ciphertext bytea",
    "identity_argument_types": "state bytea, sender_sk bytea, ciphertext bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16763,
    "schema": "pgsodium",
    "name": "crypto_signcrypt_sign_before",
    "language": "c",
    "definition": "pgsodium_crypto_signcrypt_sign_before",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_sign_before(sender bytea, recipient bytea, sender_sk bytea, recipient_pk bytea, additional bytea)\n RETURNS pgsodium.crypto_signcrypt_state_key\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_sign_before$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "sender",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "recipient",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "sender_sk",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "recipient_pk",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "sender bytea, recipient bytea, sender_sk bytea, recipient_pk bytea, additional bytea",
    "identity_argument_types": "sender bytea, recipient bytea, sender_sk bytea, recipient_pk bytea, additional bytea",
    "return_type_id": 16758,
    "return_type": "pgsodium.crypto_signcrypt_state_key",
    "return_type_relation_id": 16756,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16766,
    "schema": "pgsodium",
    "name": "crypto_signcrypt_verify_after",
    "language": "c",
    "definition": "pgsodium_crypto_signcrypt_verify_after",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_verify_after(state bytea, signature bytea, sender_pk bytea, ciphertext bytea)\n RETURNS boolean\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_verify_after$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "state",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "signature",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "sender_pk",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "ciphertext",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "state bytea, signature bytea, sender_pk bytea, ciphertext bytea",
    "identity_argument_types": "state bytea, signature bytea, sender_pk bytea, ciphertext bytea",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16765,
    "schema": "pgsodium",
    "name": "crypto_signcrypt_verify_before",
    "language": "c",
    "definition": "pgsodium_crypto_signcrypt_verify_before",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_verify_before(signature bytea, sender bytea, recipient bytea, additional bytea, sender_pk bytea, recipient_sk bytea)\n RETURNS pgsodium.crypto_signcrypt_state_key\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_verify_before$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "signature",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "sender",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "recipient",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "sender_pk",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "recipient_sk",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "signature bytea, sender bytea, recipient bytea, additional bytea, sender_pk bytea, recipient_sk bytea",
    "identity_argument_types": "signature bytea, sender bytea, recipient bytea, additional bytea, sender_pk bytea, recipient_sk bytea",
    "return_type_id": 16758,
    "return_type": "pgsodium.crypto_signcrypt_state_key",
    "return_type_relation_id": 16756,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16767,
    "schema": "pgsodium",
    "name": "crypto_signcrypt_verify_public",
    "language": "c",
    "definition": "pgsodium_crypto_signcrypt_verify_public",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_verify_public(signature bytea, sender bytea, recipient bytea, additional bytea, sender_pk bytea, ciphertext bytea)\n RETURNS boolean\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_verify_public$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "signature",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "sender",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "recipient",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "sender_pk",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "ciphertext",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "signature bytea, sender bytea, recipient bytea, additional bytea, sender_pk bytea, ciphertext bytea",
    "identity_argument_types": "signature bytea, sender bytea, recipient bytea, additional bytea, sender_pk bytea, ciphertext bytea",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16738,
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20",
    "language": "c",
    "definition": "pgsodium_crypto_stream_xchacha20",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20(bigint, bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "bigint, bytea, bytea",
    "identity_argument_types": "bigint, bytea, bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16741,
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20",
    "language": "c",
    "definition": "pgsodium_crypto_stream_xchacha20_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20(bigint, bytea, bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "bigint, bytea, bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "bigint, bytea, bigint, context bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16739,
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20_xor",
    "language": "c",
    "definition": "pgsodium_crypto_stream_xchacha20_xor",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_xor(bytea, bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_xor$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea, bytea",
    "identity_argument_types": "bytea, bytea, bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16742,
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20_xor",
    "language": "c",
    "definition": "pgsodium_crypto_stream_xchacha20_xor_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_xor(bytea, bytea, bigint, context bytea DEFAULT '\\x70676f736469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_xor_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "bytea, bytea, bigint, context bytea DEFAULT '\\x70676f736469756d'::bytea",
    "identity_argument_types": "bytea, bytea, bigint, context bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16740,
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20_xor_ic",
    "language": "c",
    "definition": "pgsodium_crypto_stream_xchacha20_xor_ic",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_xor_ic(bytea, bytea, bigint, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_xor_ic$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea, bigint, bytea",
    "identity_argument_types": "bytea, bytea, bigint, bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16743,
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20_xor_ic",
    "language": "c",
    "definition": "pgsodium_crypto_stream_xchacha20_xor_ic_by_id",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_xor_ic(bytea, bytea, bigint, bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_xor_ic_by_id$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "context",
        "type_id": 17,
        "has_default": true
      }
    ],
    "argument_types": "bytea, bytea, bigint, bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "identity_argument_types": "bytea, bytea, bigint, bigint, context bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16939,
    "schema": "pgsodium",
    "name": "encrypted_column",
    "language": "plpgsql",
    "definition": "\nDECLARE\n    expression TEXT;\n    comma TEXT;\nBEGIN\n  expression := '';\n  comma := E'        ';\n  expression := expression || comma;\n  IF m.format_type = 'text' THEN\n\t  expression := expression || format(\n\t\t$f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.encode(\n\t\t\t  pgsodium.crypto_aead_det_encrypt(\n\t\t\t\tpg_catalog.convert_to(%s, 'utf8'),\n\t\t\t\tpg_catalog.convert_to((%s)::text, 'utf8'),\n\t\t\t\t%s::uuid,\n\t\t\t\t%s\n\t\t\t  ),\n\t\t\t\t'base64') END END$f$,\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\tCOALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n\t  );\n  ELSIF m.format_type = 'bytea' THEN\n\t  expression := expression || format(\n\t\t$f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN %s IS NULL THEN NULL ELSE\n\t\t\t\t\tpgsodium.crypto_aead_det_encrypt(%s::bytea, pg_catalog.convert_to((%s)::text, 'utf8'),\n\t\t\t%s::uuid,\n\t\t\t%s\n\t\t  ) END END$f$,\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\tCOALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n\t  );\n  END IF;\n  comma := E';\\n        ';\n  RETURN expression;\nEND\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.encrypted_column(relid oid, m record)\n RETURNS text\n LANGUAGE plpgsql\n SET search_path TO ''\nAS $function$\nDECLARE\n    expression TEXT;\n    comma TEXT;\nBEGIN\n  expression := '';\n  comma := E'        ';\n  expression := expression || comma;\n  IF m.format_type = 'text' THEN\n\t  expression := expression || format(\n\t\t$f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.encode(\n\t\t\t  pgsodium.crypto_aead_det_encrypt(\n\t\t\t\tpg_catalog.convert_to(%s, 'utf8'),\n\t\t\t\tpg_catalog.convert_to((%s)::text, 'utf8'),\n\t\t\t\t%s::uuid,\n\t\t\t\t%s\n\t\t\t  ),\n\t\t\t\t'base64') END END$f$,\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\tCOALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n\t  );\n  ELSIF m.format_type = 'bytea' THEN\n\t  expression := expression || format(\n\t\t$f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN %s IS NULL THEN NULL ELSE\n\t\t\t\t\tpgsodium.crypto_aead_det_encrypt(%s::bytea, pg_catalog.convert_to((%s)::text, 'utf8'),\n\t\t\t%s::uuid,\n\t\t\t%s\n\t\t  ) END END$f$,\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\tCOALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n\t  );\n  END IF;\n  comma := E';\\n        ';\n  RETURN expression;\nEND\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "relid",
        "type_id": 26,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "m",
        "type_id": 2249,
        "has_default": false
      }
    ],
    "argument_types": "relid oid, m record",
    "identity_argument_types": "relid oid, m record",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16434,
    "schema": "extensions",
    "name": "pgp_pub_decrypt_bytea",
    "language": "c",
    "definition": "pgp_pub_decrypt_bytea",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea, text, text",
    "identity_argument_types": "bytea, bytea, text, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16937,
    "schema": "pgsodium",
    "name": "update_masks",
    "language": "plpgsql",
    "definition": "\nBEGIN\n  PERFORM pgsodium.update_mask(objoid, debug)\n    FROM pg_catalog.pg_seclabel sl\n    JOIN pg_catalog.pg_class cl ON (cl.oid = sl.objoid)\n    WHERE label ilike 'ENCRYPT%'\n       AND cl.relowner = session_user::regrole::oid\n       AND provider = 'pgsodium'\n\t   AND objoid::regclass != 'pgsodium.key'::regclass\n\t;\n  RETURN;\nEND\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.update_masks(debug boolean DEFAULT false)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO ''\nAS $function$\nBEGIN\n  PERFORM pgsodium.update_mask(objoid, debug)\n    FROM pg_catalog.pg_seclabel sl\n    JOIN pg_catalog.pg_class cl ON (cl.oid = sl.objoid)\n    WHERE label ilike 'ENCRYPT%'\n       AND cl.relowner = session_user::regrole::oid\n       AND provider = 'pgsodium'\n\t   AND objoid::regclass != 'pgsodium.key'::regclass\n\t;\n  RETURN;\nEND\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "debug",
        "type_id": 16,
        "has_default": true
      }
    ],
    "argument_types": "debug boolean DEFAULT false",
    "identity_argument_types": "debug boolean",
    "return_type_id": 2278,
    "return_type": "void",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16945,
    "schema": "pgsodium",
    "name": "key_encrypt_secret_raw_key",
    "language": "plpgsql",
    "definition": "\n\t\tBEGIN\n\t\t        new.raw_key = CASE WHEN new.raw_key IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN new.parent_key IS NULL THEN NULL ELSE\n\t\t\t\t\tpgsodium.crypto_aead_det_encrypt(new.raw_key::bytea, pg_catalog.convert_to((new.id::text || new.associated_data::text)::text, 'utf8'),\n\t\t\tnew.parent_key::uuid,\n\t\t\tnew.raw_key_nonce\n\t\t  ) END END;\n\t\tRETURN new;\n\t\tEND;\n\t\t",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.key_encrypt_secret_raw_key()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n\t\tBEGIN\n\t\t        new.raw_key = CASE WHEN new.raw_key IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN new.parent_key IS NULL THEN NULL ELSE\n\t\t\t\t\tpgsodium.crypto_aead_det_encrypt(new.raw_key::bytea, pg_catalog.convert_to((new.id::text || new.associated_data::text)::text, 'utf8'),\n\t\t\tnew.parent_key::uuid,\n\t\t\tnew.raw_key_nonce\n\t\t  ) END END;\n\t\tRETURN new;\n\t\tEND;\n\t\t$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2279,
    "return_type": "trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16435,
    "schema": "extensions",
    "name": "pgp_key_id",
    "language": "c",
    "definition": "pgp_key_id_w",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_key_id_w$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "bytea",
    "identity_argument_types": "bytea",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16436,
    "schema": "extensions",
    "name": "armor",
    "language": "c",
    "definition": "pg_armor",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.armor(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "bytea",
    "identity_argument_types": "bytea",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16437,
    "schema": "extensions",
    "name": "armor",
    "language": "c",
    "definition": "pg_armor",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 1009,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 1009,
        "has_default": false
      }
    ],
    "argument_types": "bytea, text[], text[]",
    "identity_argument_types": "bytea, text[], text[]",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16438,
    "schema": "extensions",
    "name": "dearmor",
    "language": "c",
    "definition": "pg_dearmor",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.dearmor(text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_dearmor$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "text",
    "identity_argument_types": "text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16439,
    "schema": "extensions",
    "name": "pgp_armor_headers",
    "language": "c",
    "definition": "pgp_armor_headers",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)\n RETURNS SETOF record\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_armor_headers$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "out",
        "name": "key",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "value",
        "type_id": 25,
        "has_default": null
      }
    ],
    "argument_types": "text, OUT key text, OUT value text",
    "identity_argument_types": "text, OUT key text, OUT value text",
    "return_type_id": 2249,
    "return_type": "SETOF record",
    "return_type_relation_id": null,
    "is_set_returning_function": true,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16441,
    "schema": "extensions",
    "name": "url_encode",
    "language": "sql",
    "definition": "\n    SELECT translate(encode(data, 'base64'), E'+/=\\n', '-_');\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.url_encode(data bytea)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    SELECT translate(encode(data, 'base64'), E'+/=\\n', '-_');\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "data",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "data bytea",
    "identity_argument_types": "data bytea",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16442,
    "schema": "extensions",
    "name": "url_decode",
    "language": "sql",
    "definition": "\nWITH t AS (SELECT translate(data, '-_', '+/') AS trans),\n     rem AS (SELECT length(t.trans) % 4 AS remainder FROM t) -- compute padding size\n    SELECT decode(\n        t.trans ||\n        CASE WHEN rem.remainder > 0\n           THEN repeat('=', (4 - rem.remainder))\n           ELSE '' END,\n    'base64') FROM t, rem;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.url_decode(data text)\n RETURNS bytea\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH t AS (SELECT translate(data, '-_', '+/') AS trans),\n     rem AS (SELECT length(t.trans) % 4 AS remainder FROM t) -- compute padding size\n    SELECT decode(\n        t.trans ||\n        CASE WHEN rem.remainder > 0\n           THEN repeat('=', (4 - rem.remainder))\n           ELSE '' END,\n    'base64') FROM t, rem;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "data",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "data text",
    "identity_argument_types": "data text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16832,
    "schema": "pgsodium",
    "name": "mask_role",
    "language": "plpgsql",
    "definition": "\nBEGIN\n  EXECUTE format(\n    'GRANT SELECT ON pgsodium.key TO %s',\n    masked_role);\n\n  EXECUTE format(\n    'GRANT pgsodium_keyiduser, pgsodium_keyholder TO %s',\n    masked_role);\n\n  EXECUTE format(\n    'GRANT ALL ON %s TO %s',\n    view_name,\n    masked_role);\n  RETURN;\nEND\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.mask_role(masked_role regrole, source_name text, view_name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'pg_catalog'\nAS $function$\nBEGIN\n  EXECUTE format(\n    'GRANT SELECT ON pgsodium.key TO %s',\n    masked_role);\n\n  EXECUTE format(\n    'GRANT pgsodium_keyiduser, pgsodium_keyholder TO %s',\n    masked_role);\n\n  EXECUTE format(\n    'GRANT ALL ON %s TO %s',\n    view_name,\n    masked_role);\n  RETURN;\nEND\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "masked_role",
        "type_id": 4096,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "source_name",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "view_name",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "masked_role regrole, source_name text, view_name text",
    "identity_argument_types": "masked_role regrole, source_name text, view_name text",
    "return_type_id": 2278,
    "return_type": "void",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": {
      "search_path": "pg_catalog"
    }
  },
  {
    "id": 16933,
    "schema": "pgsodium",
    "name": "create_mask_view",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  m record;\n  body text;\n  source_name text;\n  view_owner regrole = session_user;\n  rule pgsodium.masking_rule;\n  privs aclitem[];\n  priv record;\nBEGIN\n  SELECT DISTINCT * INTO STRICT rule FROM pgsodium.masking_rule WHERE attrelid = relid AND attnum = subid;\n\n  source_name := relid::regclass::text;\n\n  BEGIN\n    SELECT relacl INTO STRICT privs FROM pg_catalog.pg_class WHERE oid = rule.view_name::regclass::oid;\n  EXCEPTION\n\tWHEN undefined_table THEN\n      SELECT relacl INTO STRICT privs FROM pg_catalog.pg_class WHERE oid = relid;\n  END;\n\n  body = format(\n    $c$\n    DROP VIEW IF EXISTS %1$s;\n    CREATE VIEW %1$s %5$s AS SELECT %2$s\n    FROM %3$s;\n    ALTER VIEW %1$s OWNER TO %4$s;\n    $c$,\n    rule.view_name,\n    pgsodium.decrypted_columns(relid),\n    source_name,\n    view_owner,\n    CASE WHEN rule.security_invoker THEN 'WITH (security_invoker=true)' ELSE '' END\n  );\n  IF debug THEN\n    RAISE NOTICE '%', body;\n  END IF;\n  EXECUTE body;\n\n  FOR priv IN SELECT * FROM pg_catalog.aclexplode(privs) LOOP\n\tbody = format(\n\t  $c$\n\t  GRANT %s ON %s TO %s;\n\t  $c$,\n\t  priv.privilege_type,\n\t  rule.view_name,\n\t  priv.grantee::regrole::text\n\t);\n\tIF debug THEN\n\t  RAISE NOTICE '%', body;\n\tEND IF;\n\tEXECUTE body;\n  END LOOP;\n\n  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP\n\tIF m.key_id IS NULL AND m.key_id_column is NULL THEN\n\t  CONTINUE;\n\tELSE\n\t  body = format(\n\t\t$c$\n\t\tDROP FUNCTION IF EXISTS %1$s.\"%2$s_encrypt_secret_%3$s\"() CASCADE;\n\n\t\tCREATE OR REPLACE FUNCTION %1$s.\"%2$s_encrypt_secret_%3$s\"()\n\t\t  RETURNS TRIGGER\n\t\t  LANGUAGE plpgsql\n\t\t  AS $t$\n\t\tBEGIN\n\t\t%4$s;\n\t\tRETURN new;\n\t\tEND;\n\t\t$t$;\n\n\t\tALTER FUNCTION  %1$s.\"%2$s_encrypt_secret_%3$s\"() OWNER TO %5$s;\n\n\t\tDROP TRIGGER IF EXISTS \"%2$s_encrypt_secret_trigger_%3$s\" ON %6$s;\n\n\t\tCREATE TRIGGER \"%2$s_encrypt_secret_trigger_%3$s\"\n\t\t  BEFORE INSERT OR UPDATE OF \"%3$s\" ON %6$s\n\t\t  FOR EACH ROW\n\t\t  EXECUTE FUNCTION %1$s.\"%2$s_encrypt_secret_%3$s\" ();\n\t\t  $c$,\n\t\trule.relnamespace,\n\t\trule.relname,\n\t\tm.attname,\n\t\tpgsodium.encrypted_column(relid, m),\n\t\tview_owner,\n\t\tsource_name\n\t  );\n\t  if debug THEN\n\t\tRAISE NOTICE '%', body;\n\t  END IF;\n\t  EXECUTE body;\n\tEND IF;\n  END LOOP;\n\n  raise notice 'about to masking role % %', source_name, rule.view_name;\n  PERFORM pgsodium.mask_role(oid::regrole, source_name, rule.view_name)\n  FROM pg_roles WHERE pgsodium.has_mask(oid::regrole, source_name);\n\n  RETURN;\nEND\n  ",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.create_mask_view(relid oid, subid integer, debug boolean DEFAULT false)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog'\nAS $function$\nDECLARE\n  m record;\n  body text;\n  source_name text;\n  view_owner regrole = session_user;\n  rule pgsodium.masking_rule;\n  privs aclitem[];\n  priv record;\nBEGIN\n  SELECT DISTINCT * INTO STRICT rule FROM pgsodium.masking_rule WHERE attrelid = relid AND attnum = subid;\n\n  source_name := relid::regclass::text;\n\n  BEGIN\n    SELECT relacl INTO STRICT privs FROM pg_catalog.pg_class WHERE oid = rule.view_name::regclass::oid;\n  EXCEPTION\n\tWHEN undefined_table THEN\n      SELECT relacl INTO STRICT privs FROM pg_catalog.pg_class WHERE oid = relid;\n  END;\n\n  body = format(\n    $c$\n    DROP VIEW IF EXISTS %1$s;\n    CREATE VIEW %1$s %5$s AS SELECT %2$s\n    FROM %3$s;\n    ALTER VIEW %1$s OWNER TO %4$s;\n    $c$,\n    rule.view_name,\n    pgsodium.decrypted_columns(relid),\n    source_name,\n    view_owner,\n    CASE WHEN rule.security_invoker THEN 'WITH (security_invoker=true)' ELSE '' END\n  );\n  IF debug THEN\n    RAISE NOTICE '%', body;\n  END IF;\n  EXECUTE body;\n\n  FOR priv IN SELECT * FROM pg_catalog.aclexplode(privs) LOOP\n\tbody = format(\n\t  $c$\n\t  GRANT %s ON %s TO %s;\n\t  $c$,\n\t  priv.privilege_type,\n\t  rule.view_name,\n\t  priv.grantee::regrole::text\n\t);\n\tIF debug THEN\n\t  RAISE NOTICE '%', body;\n\tEND IF;\n\tEXECUTE body;\n  END LOOP;\n\n  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP\n\tIF m.key_id IS NULL AND m.key_id_column is NULL THEN\n\t  CONTINUE;\n\tELSE\n\t  body = format(\n\t\t$c$\n\t\tDROP FUNCTION IF EXISTS %1$s.\"%2$s_encrypt_secret_%3$s\"() CASCADE;\n\n\t\tCREATE OR REPLACE FUNCTION %1$s.\"%2$s_encrypt_secret_%3$s\"()\n\t\t  RETURNS TRIGGER\n\t\t  LANGUAGE plpgsql\n\t\t  AS $t$\n\t\tBEGIN\n\t\t%4$s;\n\t\tRETURN new;\n\t\tEND;\n\t\t$t$;\n\n\t\tALTER FUNCTION  %1$s.\"%2$s_encrypt_secret_%3$s\"() OWNER TO %5$s;\n\n\t\tDROP TRIGGER IF EXISTS \"%2$s_encrypt_secret_trigger_%3$s\" ON %6$s;\n\n\t\tCREATE TRIGGER \"%2$s_encrypt_secret_trigger_%3$s\"\n\t\t  BEFORE INSERT OR UPDATE OF \"%3$s\" ON %6$s\n\t\t  FOR EACH ROW\n\t\t  EXECUTE FUNCTION %1$s.\"%2$s_encrypt_secret_%3$s\" ();\n\t\t  $c$,\n\t\trule.relnamespace,\n\t\trule.relname,\n\t\tm.attname,\n\t\tpgsodium.encrypted_column(relid, m),\n\t\tview_owner,\n\t\tsource_name\n\t  );\n\t  if debug THEN\n\t\tRAISE NOTICE '%', body;\n\t  END IF;\n\t  EXECUTE body;\n\tEND IF;\n  END LOOP;\n\n  raise notice 'about to masking role % %', source_name, rule.view_name;\n  PERFORM pgsodium.mask_role(oid::regrole, source_name, rule.view_name)\n  FROM pg_roles WHERE pgsodium.has_mask(oid::regrole, source_name);\n\n  RETURN;\nEND\n  $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "relid",
        "type_id": 26,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "subid",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "debug",
        "type_id": 16,
        "has_default": true
      }
    ],
    "argument_types": "relid oid, subid integer, debug boolean DEFAULT false",
    "identity_argument_types": "relid oid, subid integer, debug boolean",
    "return_type_id": 2278,
    "return_type": "void",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": {
      "search_path": "pg_catalog"
    }
  },
  {
    "id": 16831,
    "schema": "pgsodium",
    "name": "trg_mask_update",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  r record;\nBEGIN\n  IF (SELECT bool_or(in_extension) FROM pg_event_trigger_ddl_commands()) THEN\n    RAISE NOTICE 'skipping pgsodium mask regeneration in extension';\n\tRETURN;\n  END IF;\n\n  FOR r IN\n    SELECT e.*\n    FROM pg_event_trigger_ddl_commands() e\n    WHERE EXISTS (\n      SELECT FROM pg_catalog.pg_class c\n      JOIN pg_catalog.pg_seclabel s ON s.classoid = c.tableoid\n                                   AND s.objoid = c.oid\n      WHERE c.tableoid = e.classid\n        AND e.objid = c.oid\n        AND s.provider = 'pgsodium'\n    )\n  LOOP\n    IF r.object_type in ('table', 'table column')\n    THEN\n      PERFORM pgsodium.update_mask(r.objid);\n    END IF;\n  END LOOP;\nEND\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.trg_mask_update()\n RETURNS event_trigger\n LANGUAGE plpgsql\n SET search_path TO ''\nAS $function$\nDECLARE\n  r record;\nBEGIN\n  IF (SELECT bool_or(in_extension) FROM pg_event_trigger_ddl_commands()) THEN\n    RAISE NOTICE 'skipping pgsodium mask regeneration in extension';\n\tRETURN;\n  END IF;\n\n  FOR r IN\n    SELECT e.*\n    FROM pg_event_trigger_ddl_commands() e\n    WHERE EXISTS (\n      SELECT FROM pg_catalog.pg_class c\n      JOIN pg_catalog.pg_seclabel s ON s.classoid = c.tableoid\n                                   AND s.objoid = c.oid\n      WHERE c.tableoid = e.classid\n        AND e.objid = c.oid\n        AND s.provider = 'pgsodium'\n    )\n  LOOP\n    IF r.object_type in ('table', 'table column')\n    THEN\n      PERFORM pgsodium.update_mask(r.objid);\n    END IF;\n  END LOOP;\nEND\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 3838,
    "return_type": "event_trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16818,
    "schema": "pgsodium",
    "name": "crypto_aead_det_decrypt",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.decrypted_raw_key, nonce);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.key_id, key.key_context, nonce);\nEND;\n  ",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_decrypt(message bytea, additional bytea, key_uuid uuid, nonce bytea)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.decrypted_raw_key, nonce);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.key_id, key.key_context, nonce);\nEND;\n  $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, additional bytea, key_uuid uuid, nonce bytea",
    "identity_argument_types": "message bytea, additional bytea, key_uuid uuid, nonce bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16817,
    "schema": "pgsodium",
    "name": "crypto_aead_det_encrypt",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.decrypted_raw_key, nonce);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.key_id, key.key_context, nonce);\nEND;\n  ",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_encrypt(message bytea, additional bytea, key_uuid uuid, nonce bytea)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.decrypted_raw_key, nonce);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.key_id, key.key_context, nonce);\nEND;\n  $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "additional",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "key_uuid",
        "type_id": 2950,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "nonce",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "message bytea, additional bytea, key_uuid uuid, nonce bytea",
    "identity_argument_types": "message bytea, additional bytea, key_uuid uuid, nonce bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": true,
    "config_params": {
      "search_path": "\"\""
    }
  },
  {
    "id": 16751,
    "schema": "pgsodium",
    "name": "crypto_aead_det_keygen",
    "language": "c",
    "definition": "pgsodium_crypto_aead_det_keygen",
    "complete_statement": "CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_keygen$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16974,
    "schema": "vault",
    "name": "secrets_encrypt_secret_secret",
    "language": "plpgsql",
    "definition": "\n\t\tBEGIN\n\t\t        new.secret = CASE WHEN new.secret IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN new.key_id IS NULL THEN NULL ELSE pg_catalog.encode(\n\t\t\t  pgsodium.crypto_aead_det_encrypt(\n\t\t\t\tpg_catalog.convert_to(new.secret, 'utf8'),\n\t\t\t\tpg_catalog.convert_to((new.id::text || new.description::text || new.created_at::text || new.updated_at::text)::text, 'utf8'),\n\t\t\t\tnew.key_id::uuid,\n\t\t\t\tnew.nonce\n\t\t\t  ),\n\t\t\t\t'base64') END END;\n\t\tRETURN new;\n\t\tEND;\n\t\t",
    "complete_statement": "CREATE OR REPLACE FUNCTION vault.secrets_encrypt_secret_secret()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n\t\tBEGIN\n\t\t        new.secret = CASE WHEN new.secret IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN new.key_id IS NULL THEN NULL ELSE pg_catalog.encode(\n\t\t\t  pgsodium.crypto_aead_det_encrypt(\n\t\t\t\tpg_catalog.convert_to(new.secret, 'utf8'),\n\t\t\t\tpg_catalog.convert_to((new.id::text || new.description::text || new.created_at::text || new.updated_at::text)::text, 'utf8'),\n\t\t\t\tnew.key_id::uuid,\n\t\t\t\tnew.nonce\n\t\t\t  ),\n\t\t\t\t'base64') END END;\n\t\tRETURN new;\n\t\tEND;\n\t\t$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2279,
    "return_type": "trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16976,
    "schema": "vault",
    "name": "create_secret",
    "language": "sql",
    "definition": "\n    INSERT INTO vault.secrets (secret, name, description, key_id)\n    VALUES (\n        new_secret,\n        new_name,\n        new_description,\n        CASE WHEN new_key_id IS NULL THEN (pgsodium.create_key()).id ELSE new_key_id END)\n    RETURNING id;\n    ",
    "complete_statement": "CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS uuid\n LANGUAGE sql\nAS $function$\n    INSERT INTO vault.secrets (secret, name, description, key_id)\n    VALUES (\n        new_secret,\n        new_name,\n        new_description,\n        CASE WHEN new_key_id IS NULL THEN (pgsodium.create_key()).id ELSE new_key_id END)\n    RETURNING id;\n    $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "new_secret",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "new_name",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "new_description",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "new_key_id",
        "type_id": 2950,
        "has_default": true
      }
    ],
    "argument_types": "new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid",
    "identity_argument_types": "new_secret text, new_name text, new_description text, new_key_id uuid",
    "return_type_id": 2950,
    "return_type": "uuid",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16977,
    "schema": "vault",
    "name": "update_secret",
    "language": "sql",
    "definition": "\n\tUPDATE vault.decrypted_secrets s\n    SET\n        secret = CASE WHEN new_secret IS NULL THEN s.decrypted_secret ELSE new_secret END,\n        name = CASE WHEN new_name IS NULL THEN s.name ELSE new_name END,\n        description = CASE WHEN new_description IS NULL THEN s.description ELSE new_description END,\n        key_id = CASE WHEN new_key_id IS NULL THEN s.key_id ELSE new_key_id END,\n        updated_at = CURRENT_TIMESTAMP\n    WHERE s.id = secret_id\n    ",
    "complete_statement": "CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE sql\nAS $function$\n\tUPDATE vault.decrypted_secrets s\n    SET\n        secret = CASE WHEN new_secret IS NULL THEN s.decrypted_secret ELSE new_secret END,\n        name = CASE WHEN new_name IS NULL THEN s.name ELSE new_name END,\n        description = CASE WHEN new_description IS NULL THEN s.description ELSE new_description END,\n        key_id = CASE WHEN new_key_id IS NULL THEN s.key_id ELSE new_key_id END,\n        updated_at = CURRENT_TIMESTAMP\n    WHERE s.id = secret_id\n    $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "secret_id",
        "type_id": 2950,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "new_secret",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "new_name",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "new_description",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "new_key_id",
        "type_id": 2950,
        "has_default": true
      }
    ],
    "argument_types": "secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid",
    "identity_argument_types": "secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid",
    "return_type_id": 2278,
    "return_type": "void",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16444,
    "schema": "extensions",
    "name": "sign",
    "language": "sql",
    "definition": "\nWITH\n  header AS (\n    SELECT extensions.url_encode(convert_to('{\"alg\":\"' || algorithm || '\",\"typ\":\"JWT\"}', 'utf8')) AS data\n    ),\n  payload AS (\n    SELECT extensions.url_encode(convert_to(payload::text, 'utf8')) AS data\n    ),\n  signables AS (\n    SELECT header.data || '.' || payload.data AS data FROM header, payload\n    )\nSELECT\n    signables.data || '.' ||\n    extensions.algorithm_sign(signables.data, secret, algorithm) FROM signables;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.sign(payload json, secret text, algorithm text DEFAULT 'HS256'::text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH\n  header AS (\n    SELECT extensions.url_encode(convert_to('{\"alg\":\"' || algorithm || '\",\"typ\":\"JWT\"}', 'utf8')) AS data\n    ),\n  payload AS (\n    SELECT extensions.url_encode(convert_to(payload::text, 'utf8')) AS data\n    ),\n  signables AS (\n    SELECT header.data || '.' || payload.data AS data FROM header, payload\n    )\nSELECT\n    signables.data || '.' ||\n    extensions.algorithm_sign(signables.data, secret, algorithm) FROM signables;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "payload",
        "type_id": 114,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "secret",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "algorithm",
        "type_id": 25,
        "has_default": true
      }
    ],
    "argument_types": "payload json, secret text, algorithm text DEFAULT 'HS256'::text",
    "identity_argument_types": "payload json, secret text, algorithm text",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16419,
    "schema": "extensions",
    "name": "pgp_sym_encrypt",
    "language": "c",
    "definition": "pgp_sym_encrypt_text",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "text, text, text",
    "identity_argument_types": "text, text, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16420,
    "schema": "extensions",
    "name": "pgp_sym_encrypt_bytea",
    "language": "c",
    "definition": "pgp_sym_encrypt_bytea",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, text, text",
    "identity_argument_types": "bytea, text, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16421,
    "schema": "extensions",
    "name": "pgp_sym_decrypt",
    "language": "c",
    "definition": "pgp_sym_decrypt_text",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, text",
    "identity_argument_types": "bytea, text",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16422,
    "schema": "extensions",
    "name": "pgp_sym_decrypt_bytea",
    "language": "c",
    "definition": "pgp_sym_decrypt_bytea",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, text",
    "identity_argument_types": "bytea, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16423,
    "schema": "extensions",
    "name": "pgp_sym_decrypt",
    "language": "c",
    "definition": "pgp_sym_decrypt_text",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, text, text",
    "identity_argument_types": "bytea, text, text",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16428,
    "schema": "extensions",
    "name": "pgp_pub_encrypt_bytea",
    "language": "c",
    "definition": "pgp_pub_encrypt_bytea",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea, text",
    "identity_argument_types": "bytea, bytea, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16429,
    "schema": "extensions",
    "name": "pgp_pub_decrypt",
    "language": "c",
    "definition": "pgp_pub_decrypt_text",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea",
    "identity_argument_types": "bytea, bytea",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16430,
    "schema": "extensions",
    "name": "pgp_pub_decrypt_bytea",
    "language": "c",
    "definition": "pgp_pub_decrypt_bytea",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea",
    "identity_argument_types": "bytea, bytea",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16431,
    "schema": "extensions",
    "name": "pgp_pub_decrypt",
    "language": "c",
    "definition": "pgp_pub_decrypt_text",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea, text",
    "identity_argument_types": "bytea, bytea, text",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16432,
    "schema": "extensions",
    "name": "pgp_pub_decrypt_bytea",
    "language": "c",
    "definition": "pgp_pub_decrypt_bytea",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea, text",
    "identity_argument_types": "bytea, bytea, text",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16433,
    "schema": "extensions",
    "name": "pgp_pub_decrypt",
    "language": "c",
    "definition": "pgp_pub_decrypt_text",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "bytea, bytea, text, text",
    "identity_argument_types": "bytea, bytea, text, text",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16443,
    "schema": "extensions",
    "name": "algorithm_sign",
    "language": "sql",
    "definition": "\nWITH\n  alg AS (\n    SELECT CASE\n      WHEN algorithm = 'HS256' THEN 'sha256'\n      WHEN algorithm = 'HS384' THEN 'sha384'\n      WHEN algorithm = 'HS512' THEN 'sha512'\n      ELSE '' END AS id)  -- hmac throws error\nSELECT extensions.url_encode(extensions.hmac(signables, secret, alg.id)) FROM alg;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.algorithm_sign(signables text, secret text, algorithm text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH\n  alg AS (\n    SELECT CASE\n      WHEN algorithm = 'HS256' THEN 'sha256'\n      WHEN algorithm = 'HS384' THEN 'sha384'\n      WHEN algorithm = 'HS512' THEN 'sha512'\n      ELSE '' END AS id)  -- hmac throws error\nSELECT extensions.url_encode(extensions.hmac(signables, secret, alg.id)) FROM alg;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "signables",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "secret",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "algorithm",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "signables text, secret text, algorithm text",
    "identity_argument_types": "signables text, secret text, algorithm text",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16572,
    "schema": "extensions",
    "name": "pg_stat_statements_reset",
    "language": "c",
    "definition": "pg_stat_statements_reset_1_7",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0)\n RETURNS void\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_reset_1_7$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "userid",
        "type_id": 26,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "dbid",
        "type_id": 26,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "queryid",
        "type_id": 20,
        "has_default": true
      }
    ],
    "argument_types": "userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0",
    "identity_argument_types": "userid oid, dbid oid, queryid bigint",
    "return_type_id": 2278,
    "return_type": "void",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16590,
    "schema": "extensions",
    "name": "pg_stat_statements",
    "language": "c",
    "definition": "pg_stat_statements_1_10",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision)\n RETURNS SETOF record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_1_10$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "showtext",
        "type_id": 16,
        "has_default": false
      },
      {
        "mode": "out",
        "name": "userid",
        "type_id": 26,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "dbid",
        "type_id": 26,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "toplevel",
        "type_id": 16,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "queryid",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "query",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "plans",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "total_plan_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "min_plan_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "max_plan_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "mean_plan_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "stddev_plan_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "calls",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "total_exec_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "min_exec_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "max_exec_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "mean_exec_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "stddev_exec_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "rows",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "shared_blks_hit",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "shared_blks_read",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "shared_blks_dirtied",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "shared_blks_written",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "local_blks_hit",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "local_blks_read",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "local_blks_dirtied",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "local_blks_written",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "temp_blks_read",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "temp_blks_written",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "blk_read_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "blk_write_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "temp_blk_read_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "temp_blk_write_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "wal_records",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "wal_fpi",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "wal_bytes",
        "type_id": 1700,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "jit_functions",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "jit_generation_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "jit_inlining_count",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "jit_inlining_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "jit_optimization_count",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "jit_optimization_time",
        "type_id": 701,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "jit_emission_count",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "out",
        "name": "jit_emission_time",
        "type_id": 701,
        "has_default": null
      }
    ],
    "argument_types": "showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision",
    "identity_argument_types": "showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision",
    "return_type_id": 2249,
    "return_type": "SETOF record",
    "return_type_relation_id": null,
    "is_set_returning_function": true,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16604,
    "schema": "extensions",
    "name": "pgrst_drop_watch",
    "language": "plpgsql",
    "definition": "\nDECLARE\n  obj record;\nBEGIN\n  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n  LOOP\n    IF obj.object_type IN (\n      'schema'\n    , 'table'\n    , 'foreign table'\n    , 'view'\n    , 'materialized view'\n    , 'function'\n    , 'trigger'\n    , 'type'\n    , 'rule'\n    )\n    AND obj.is_temporary IS false -- no pg_temp objects\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; ",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  obj record;\nBEGIN\n  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n  LOOP\n    IF obj.object_type IN (\n      'schema'\n    , 'table'\n    , 'foreign table'\n    , 'view'\n    , 'materialized view'\n    , 'function'\n    , 'trigger'\n    , 'type'\n    , 'rule'\n    )\n    AND obj.is_temporary IS false -- no pg_temp objects\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 3838,
    "return_type": "event_trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16614,
    "schema": "extensions",
    "name": "set_graphql_placeholder",
    "language": "plpgsql",
    "definition": "\n    DECLARE\n    graphql_is_dropped bool;\n    BEGIN\n    graphql_is_dropped = (\n        SELECT ev.schema_name = 'graphql_public'\n        FROM pg_event_trigger_dropped_objects() AS ev\n        WHERE ev.schema_name = 'graphql_public'\n    );\n\n    IF graphql_is_dropped\n    THEN\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language plpgsql\n        as $$\n            DECLARE\n                server_version float;\n            BEGIN\n                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);\n\n                IF server_version >= 14 THEN\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql extension is not enabled.'\n                            )\n                        )\n                    );\n                ELSE\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'\n                            )\n                        )\n                    );\n                END IF;\n            END;\n        $$;\n    END IF;\n\n    END;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\n    DECLARE\n    graphql_is_dropped bool;\n    BEGIN\n    graphql_is_dropped = (\n        SELECT ev.schema_name = 'graphql_public'\n        FROM pg_event_trigger_dropped_objects() AS ev\n        WHERE ev.schema_name = 'graphql_public'\n    );\n\n    IF graphql_is_dropped\n    THEN\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language plpgsql\n        as $$\n            DECLARE\n                server_version float;\n            BEGIN\n                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);\n\n                IF server_version >= 14 THEN\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql extension is not enabled.'\n                            )\n                        )\n                    );\n                ELSE\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'\n                            )\n                        )\n                    );\n                END IF;\n            END;\n        $$;\n    END IF;\n\n    END;\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 3838,
    "return_type": "event_trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17881,
    "schema": "public",
    "name": "halfvec_ne",
    "language": "c",
    "definition": "halfvec_ne",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_ne(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_ne$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17882,
    "schema": "public",
    "name": "halfvec_ge",
    "language": "c",
    "definition": "halfvec_ge",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_ge(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_ge$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17883,
    "schema": "public",
    "name": "halfvec_gt",
    "language": "c",
    "definition": "halfvec_gt",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_gt(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_gt$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17884,
    "schema": "public",
    "name": "halfvec_cmp",
    "language": "c",
    "definition": "halfvec_cmp",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_cmp(halfvec, halfvec)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_cmp$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 23,
    "return_type": "integer",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17885,
    "schema": "public",
    "name": "halfvec_l2_squared_distance",
    "language": "c",
    "definition": "halfvec_l2_squared_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_l2_squared_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l2_squared_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17886,
    "schema": "public",
    "name": "halfvec_negative_inner_product",
    "language": "c",
    "definition": "halfvec_negative_inner_product",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_negative_inner_product(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_negative_inner_product$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17887,
    "schema": "public",
    "name": "halfvec_spherical_distance",
    "language": "c",
    "definition": "halfvec_spherical_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_spherical_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_spherical_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17888,
    "schema": "public",
    "name": "halfvec_accum",
    "language": "c",
    "definition": "halfvec_accum",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_accum(double precision[], halfvec)\n RETURNS double precision[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_accum$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1022,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "double precision[], halfvec",
    "identity_argument_types": "double precision[], halfvec",
    "return_type_id": 1022,
    "return_type": "double precision[]",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16992,
    "schema": "graphql_public",
    "name": "graphql",
    "language": "sql",
    "definition": "\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        ",
    "complete_statement": "CREATE OR REPLACE FUNCTION graphql_public.graphql(\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE sql\nAS $function$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "operationName",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "query",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "variables",
        "type_id": 3802,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "extensions",
        "type_id": 3802,
        "has_default": true
      }
    ],
    "argument_types": "\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb",
    "identity_argument_types": "\"operationName\" text, query text, variables jsonb, extensions jsonb",
    "return_type_id": 3802,
    "return_type": "jsonb",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16983,
    "schema": "graphql",
    "name": "_internal_resolve",
    "language": "c",
    "definition": "resolve_wrapper",
    "complete_statement": "CREATE OR REPLACE FUNCTION graphql._internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE c\nAS '$libdir/pg_graphql', $function$resolve_wrapper$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "query",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "variables",
        "type_id": 3802,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "operationName",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "extensions",
        "type_id": 3802,
        "has_default": true
      }
    ],
    "argument_types": "query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb",
    "identity_argument_types": "query text, variables jsonb, \"operationName\" text, extensions jsonb",
    "return_type_id": 3802,
    "return_type": "jsonb",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16984,
    "schema": "graphql",
    "name": "exception",
    "language": "plpgsql",
    "definition": "\nbegin\n    raise exception using errcode='22000', message=message;\nend;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION graphql.exception(message text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nbegin\n    raise exception using errcode='22000', message=message;\nend;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "message",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "message text",
    "identity_argument_types": "message text",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16985,
    "schema": "graphql",
    "name": "comment_directive",
    "language": "sql",
    "definition": "\n    /*\n    comment on column public.account.name is '@graphql.name: myField'\n    */\n    select\n        coalesce(\n            (\n                regexp_match(\n                    comment_,\n                    '@graphql\\((.+)\\)'\n                )\n            )[1]::jsonb,\n            jsonb_build_object()\n        )\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION graphql.comment_directive(comment_ text)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    comment on column public.account.name is '@graphql.name: myField'\n    */\n    select\n        coalesce(\n            (\n                regexp_match(\n                    comment_,\n                    '@graphql\\((.+)\\)'\n                )\n            )[1]::jsonb,\n            jsonb_build_object()\n        )\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "comment_",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "comment_ text",
    "identity_argument_types": "comment_ text",
    "return_type_id": 3802,
    "return_type": "jsonb",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16987,
    "schema": "graphql",
    "name": "increment_schema_version",
    "language": "plpgsql",
    "definition": "\nbegin\n    perform nextval('graphql.seq_schema_version');\nend;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION graphql.increment_schema_version()\n RETURNS event_trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n    perform nextval('graphql.seq_schema_version');\nend;\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 3838,
    "return_type": "event_trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": null
  },
  {
    "id": 16988,
    "schema": "graphql",
    "name": "get_schema_version",
    "language": "sql",
    "definition": "\n    select last_value from graphql.seq_schema_version;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION graphql.get_schema_version()\n RETURNS integer\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n    select last_value from graphql.seq_schema_version;\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 23,
    "return_type": "integer",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": null
  },
  {
    "id": 17889,
    "schema": "public",
    "name": "halfvec_avg",
    "language": "c",
    "definition": "halfvec_avg",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_avg(double precision[])\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_avg$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1022,
        "has_default": false
      }
    ],
    "argument_types": "double precision[]",
    "identity_argument_types": "double precision[]",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17890,
    "schema": "public",
    "name": "halfvec_combine",
    "language": "c",
    "definition": "vector_combine",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_combine(double precision[], double precision[])\n RETURNS double precision[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_combine$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1022,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 1022,
        "has_default": false
      }
    ],
    "argument_types": "double precision[], double precision[]",
    "identity_argument_types": "double precision[], double precision[]",
    "return_type_id": 1022,
    "return_type": "double precision[]",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17893,
    "schema": "public",
    "name": "halfvec",
    "language": "c",
    "definition": "halfvec",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec(halfvec, integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, integer, boolean",
    "identity_argument_types": "halfvec, integer, boolean",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17894,
    "schema": "public",
    "name": "halfvec_to_vector",
    "language": "c",
    "definition": "halfvec_to_vector",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_to_vector(halfvec, integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_to_vector$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, integer, boolean",
    "identity_argument_types": "halfvec, integer, boolean",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17895,
    "schema": "public",
    "name": "vector_to_halfvec",
    "language": "c",
    "definition": "vector_to_halfvec",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_to_halfvec(vector, integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_to_halfvec$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "vector, integer, boolean",
    "identity_argument_types": "vector, integer, boolean",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17896,
    "schema": "public",
    "name": "array_to_halfvec",
    "language": "c",
    "definition": "array_to_halfvec",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.array_to_halfvec(integer[], integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_halfvec$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1007,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "integer[], integer, boolean",
    "identity_argument_types": "integer[], integer, boolean",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17897,
    "schema": "public",
    "name": "array_to_halfvec",
    "language": "c",
    "definition": "array_to_halfvec",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.array_to_halfvec(real[], integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_halfvec$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1021,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "real[], integer, boolean",
    "identity_argument_types": "real[], integer, boolean",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17898,
    "schema": "public",
    "name": "array_to_halfvec",
    "language": "c",
    "definition": "array_to_halfvec",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.array_to_halfvec(double precision[], integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_halfvec$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1022,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "double precision[], integer, boolean",
    "identity_argument_types": "double precision[], integer, boolean",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17899,
    "schema": "public",
    "name": "array_to_halfvec",
    "language": "c",
    "definition": "array_to_halfvec",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.array_to_halfvec(numeric[], integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_halfvec$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1231,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "numeric[], integer, boolean",
    "identity_argument_types": "numeric[], integer, boolean",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17900,
    "schema": "public",
    "name": "halfvec_to_float4",
    "language": "c",
    "definition": "halfvec_to_float4",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_to_float4(halfvec, integer, boolean)\n RETURNS real[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_to_float4$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, integer, boolean",
    "identity_argument_types": "halfvec, integer, boolean",
    "return_type_id": 1021,
    "return_type": "real[]",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17973,
    "schema": "public",
    "name": "hamming_distance",
    "language": "c",
    "definition": "hamming_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.hamming_distance(bit, bit)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$hamming_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1560,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 1560,
        "has_default": false
      }
    ],
    "argument_types": "bit, bit",
    "identity_argument_types": "bit, bit",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17974,
    "schema": "public",
    "name": "jaccard_distance",
    "language": "c",
    "definition": "jaccard_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.jaccard_distance(bit, bit)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$jaccard_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1560,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 1560,
        "has_default": false
      }
    ],
    "argument_types": "bit, bit",
    "identity_argument_types": "bit, bit",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 16991,
    "schema": "graphql",
    "name": "resolve",
    "language": "plpgsql",
    "definition": "\ndeclare\n    res jsonb;\n    message_text text;\nbegin\n  begin\n    select graphql._internal_resolve(\"query\" := \"query\",\n                                     \"variables\" := \"variables\",\n                                     \"operationName\" := \"operationName\",\n                                     \"extensions\" := \"extensions\") into res;\n    return res;\n  exception\n    when others then\n    get stacked diagnostics message_text = message_text;\n    return\n    jsonb_build_object('data', null,\n                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));\n  end;\nend;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION graphql.resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    res jsonb;\n    message_text text;\nbegin\n  begin\n    select graphql._internal_resolve(\"query\" := \"query\",\n                                     \"variables\" := \"variables\",\n                                     \"operationName\" := \"operationName\",\n                                     \"extensions\" := \"extensions\") into res;\n    return res;\n  exception\n    when others then\n    get stacked diagnostics message_text = message_text;\n    return\n    jsonb_build_object('data', null,\n                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));\n  end;\nend;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "query",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "variables",
        "type_id": 3802,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "operationName",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "extensions",
        "type_id": 3802,
        "has_default": true
      }
    ],
    "argument_types": "query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb",
    "identity_argument_types": "query text, variables jsonb, \"operationName\" text, extensions jsonb",
    "return_type_id": 3802,
    "return_type": "jsonb",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17007,
    "schema": "net",
    "name": "check_worker_is_up",
    "language": "plpgsql",
    "definition": "\nbegin\n  if not exists (select pid from pg_stat_activity where backend_type ilike '%pg_net%') then\n    raise exception using\n      message = 'the pg_net background worker is not up'\n    , detail  = 'the pg_net background worker is down due to an internal error and cannot process requests'\n    , hint    = 'make sure that you didn''t modify any of pg_net internal tables';\n  end if;\nend\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION net.check_worker_is_up()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nbegin\n  if not exists (select pid from pg_stat_activity where backend_type ilike '%pg_net%') then\n    raise exception using\n      message = 'the pg_net background worker is not up'\n    , detail  = 'the pg_net background worker is down due to an internal error and cannot process requests'\n    , hint    = 'make sure that you didn''t modify any of pg_net internal tables';\n  end if;\nend\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2278,
    "return_type": "void",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17015,
    "schema": "net",
    "name": "_await_response",
    "language": "plpgsql",
    "definition": "\ndeclare\n    rec net._http_response;\nbegin\n    while rec is null loop\n        select *\n        into rec\n        from net._http_response\n        where id = request_id;\n\n        if rec is null then\n            -- Wait 50 ms before checking again\n            perform pg_sleep(0.05);\n        end if;\n    end loop;\n\n    return true;\nend;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION net._await_response(request_id bigint)\n RETURNS boolean\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\ndeclare\n    rec net._http_response;\nbegin\n    while rec is null loop\n        select *\n        into rec\n        from net._http_response\n        where id = request_id;\n\n        if rec is null then\n            -- Wait 50 ms before checking again\n            perform pg_sleep(0.05);\n        end if;\n    end loop;\n\n    return true;\nend;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "request_id",
        "type_id": 20,
        "has_default": false
      }
    ],
    "argument_types": "request_id bigint",
    "identity_argument_types": "request_id bigint",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17016,
    "schema": "net",
    "name": "_urlencode_string",
    "language": "c",
    "definition": "_urlencode_string",
    "complete_statement": "CREATE OR REPLACE FUNCTION net._urlencode_string(string character varying)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS 'pg_net', $function$_urlencode_string$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "string",
        "type_id": 1043,
        "has_default": false
      }
    ],
    "argument_types": "string character varying",
    "identity_argument_types": "string character varying",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17017,
    "schema": "net",
    "name": "_encode_url_with_params_array",
    "language": "c",
    "definition": "_encode_url_with_params_array",
    "complete_statement": "CREATE OR REPLACE FUNCTION net._encode_url_with_params_array(url text, params_array text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS 'pg_net', $function$_encode_url_with_params_array$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "url",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "params_array",
        "type_id": 1009,
        "has_default": false
      }
    ],
    "argument_types": "url text, params_array text[]",
    "identity_argument_types": "url text, params_array text[]",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17018,
    "schema": "net",
    "name": "worker_restart",
    "language": "c",
    "definition": "worker_restart",
    "complete_statement": "CREATE OR REPLACE FUNCTION net.worker_restart()\n RETURNS boolean\n LANGUAGE c\nAS 'pg_net', $function$worker_restart$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17021,
    "schema": "net",
    "name": "http_delete",
    "language": "plpgsql",
    "definition": "\ndeclare\n    request_id bigint;\n    params_array text[];\nbegin\n    select coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into params_array\n    from jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, timeout_milliseconds)\n    values (\n        'DELETE',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION net.http_delete(url text, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{}'::jsonb, timeout_milliseconds integer DEFAULT 5000)\n RETURNS bigint\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\ndeclare\n    request_id bigint;\n    params_array text[];\nbegin\n    select coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into params_array\n    from jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, timeout_milliseconds)\n    values (\n        'DELETE',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "url",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "params",
        "type_id": 3802,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "headers",
        "type_id": 3802,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "timeout_milliseconds",
        "type_id": 23,
        "has_default": true
      }
    ],
    "argument_types": "url text, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{}'::jsonb, timeout_milliseconds integer DEFAULT 5000",
    "identity_argument_types": "url text, params jsonb, headers jsonb, timeout_milliseconds integer",
    "return_type_id": 20,
    "return_type": "bigint",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17994,
    "schema": "public",
    "name": "sparsevec_in",
    "language": "c",
    "definition": "sparsevec_in",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_in(cstring, oid, integer)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_in$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 2275,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 26,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      }
    ],
    "argument_types": "cstring, oid, integer",
    "identity_argument_types": "cstring, oid, integer",
    "return_type_id": 17993,
    "return_type": "sparsevec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17995,
    "schema": "public",
    "name": "sparsevec_out",
    "language": "c",
    "definition": "sparsevec_out",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_out(sparsevec)\n RETURNS cstring\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_out$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec",
    "identity_argument_types": "sparsevec",
    "return_type_id": 2275,
    "return_type": "cstring",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17996,
    "schema": "public",
    "name": "sparsevec_typmod_in",
    "language": "c",
    "definition": "sparsevec_typmod_in",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_typmod_in(cstring[])\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_typmod_in$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1263,
        "has_default": false
      }
    ],
    "argument_types": "cstring[]",
    "identity_argument_types": "cstring[]",
    "return_type_id": 23,
    "return_type": "integer",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17997,
    "schema": "public",
    "name": "sparsevec_recv",
    "language": "c",
    "definition": "sparsevec_recv",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_recv(internal, oid, integer)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_recv$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 2281,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 26,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      }
    ],
    "argument_types": "internal, oid, integer",
    "identity_argument_types": "internal, oid, integer",
    "return_type_id": 17993,
    "return_type": "sparsevec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17998,
    "schema": "public",
    "name": "sparsevec_send",
    "language": "c",
    "definition": "sparsevec_send",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_send(sparsevec)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_send$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec",
    "identity_argument_types": "sparsevec",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18000,
    "schema": "public",
    "name": "l2_distance",
    "language": "c",
    "definition": "sparsevec_l2_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.l2_distance(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l2_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, sparsevec",
    "identity_argument_types": "sparsevec, sparsevec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18001,
    "schema": "public",
    "name": "inner_product",
    "language": "c",
    "definition": "sparsevec_inner_product",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.inner_product(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_inner_product$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, sparsevec",
    "identity_argument_types": "sparsevec, sparsevec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18002,
    "schema": "public",
    "name": "cosine_distance",
    "language": "c",
    "definition": "sparsevec_cosine_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.cosine_distance(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_cosine_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, sparsevec",
    "identity_argument_types": "sparsevec, sparsevec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18003,
    "schema": "public",
    "name": "l1_distance",
    "language": "c",
    "definition": "sparsevec_l1_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.l1_distance(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l1_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, sparsevec",
    "identity_argument_types": "sparsevec, sparsevec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18004,
    "schema": "public",
    "name": "l2_norm",
    "language": "c",
    "definition": "sparsevec_l2_norm",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.l2_norm(sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l2_norm$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec",
    "identity_argument_types": "sparsevec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18005,
    "schema": "public",
    "name": "l2_normalize",
    "language": "c",
    "definition": "sparsevec_l2_normalize",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.l2_normalize(sparsevec)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l2_normalize$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec",
    "identity_argument_types": "sparsevec",
    "return_type_id": 17993,
    "return_type": "sparsevec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17035,
    "schema": "net",
    "name": "_http_collect_response",
    "language": "plpgsql",
    "definition": "\ndeclare\n    rec net._http_response;\n    req_exists boolean;\nbegin\n\n    if not async then\n        perform net._await_response(request_id);\n    end if;\n\n    select *\n    into rec\n    from net._http_response\n    where id = request_id;\n\n    if rec is null or rec.error_msg is not null then\n        -- The request is either still processing or the request_id provided does not exist\n\n        -- TODO: request in progress is indistinguishable from request that doesn't exist\n\n        -- No request matching request_id found\n        return (\n            'ERROR',\n            coalesce(rec.error_msg, 'request matching request_id not found'),\n            null\n        )::net.http_response_result;\n\n    end if;\n\n    -- Return a valid, populated http_response_result\n    return (\n        'SUCCESS',\n        'ok',\n        (\n            rec.status_code,\n            rec.headers,\n            rec.content\n        )::net.http_response\n    )::net.http_response_result;\nend;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION net._http_collect_response(request_id bigint, async boolean DEFAULT true)\n RETURNS net.http_response_result\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\ndeclare\n    rec net._http_response;\n    req_exists boolean;\nbegin\n\n    if not async then\n        perform net._await_response(request_id);\n    end if;\n\n    select *\n    into rec\n    from net._http_response\n    where id = request_id;\n\n    if rec is null or rec.error_msg is not null then\n        -- The request is either still processing or the request_id provided does not exist\n\n        -- TODO: request in progress is indistinguishable from request that doesn't exist\n\n        -- No request matching request_id found\n        return (\n            'ERROR',\n            coalesce(rec.error_msg, 'request matching request_id not found'),\n            null\n        )::net.http_response_result;\n\n    end if;\n\n    -- Return a valid, populated http_response_result\n    return (\n        'SUCCESS',\n        'ok',\n        (\n            rec.status_code,\n            rec.headers,\n            rec.content\n        )::net.http_response\n    )::net.http_response_result;\nend;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "request_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "async",
        "type_id": 16,
        "has_default": true
      }
    ],
    "argument_types": "request_id bigint, async boolean DEFAULT true",
    "identity_argument_types": "request_id bigint, async boolean",
    "return_type_id": 17034,
    "return_type": "net.http_response_result",
    "return_type_relation_id": 17032,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17036,
    "schema": "net",
    "name": "http_collect_response",
    "language": "plpgsql",
    "definition": "\nbegin\n  raise notice 'The net.http_collect_response function is deprecated.';\n  select net._http_collect_response(request_id, async);\nend;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION net.http_collect_response(request_id bigint, async boolean DEFAULT true)\n RETURNS net.http_response_result\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\nbegin\n  raise notice 'The net.http_collect_response function is deprecated.';\n  select net._http_collect_response(request_id, async);\nend;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "request_id",
        "type_id": 20,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "async",
        "type_id": 16,
        "has_default": true
      }
    ],
    "argument_types": "request_id bigint, async boolean DEFAULT true",
    "identity_argument_types": "request_id bigint, async boolean",
    "return_type_id": 17034,
    "return_type": "net.http_response_result",
    "return_type_relation_id": 17032,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18006,
    "schema": "public",
    "name": "sparsevec_lt",
    "language": "c",
    "definition": "sparsevec_lt",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_lt(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_lt$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, sparsevec",
    "identity_argument_types": "sparsevec, sparsevec",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18007,
    "schema": "public",
    "name": "sparsevec_le",
    "language": "c",
    "definition": "sparsevec_le",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_le(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_le$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, sparsevec",
    "identity_argument_types": "sparsevec, sparsevec",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18008,
    "schema": "public",
    "name": "sparsevec_eq",
    "language": "c",
    "definition": "sparsevec_eq",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_eq(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_eq$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, sparsevec",
    "identity_argument_types": "sparsevec, sparsevec",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18009,
    "schema": "public",
    "name": "sparsevec_ne",
    "language": "c",
    "definition": "sparsevec_ne",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_ne(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_ne$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, sparsevec",
    "identity_argument_types": "sparsevec, sparsevec",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18010,
    "schema": "public",
    "name": "sparsevec_ge",
    "language": "c",
    "definition": "sparsevec_ge",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_ge(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_ge$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, sparsevec",
    "identity_argument_types": "sparsevec, sparsevec",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18011,
    "schema": "public",
    "name": "sparsevec_gt",
    "language": "c",
    "definition": "sparsevec_gt",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_gt(sparsevec, sparsevec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_gt$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, sparsevec",
    "identity_argument_types": "sparsevec, sparsevec",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18012,
    "schema": "public",
    "name": "sparsevec_cmp",
    "language": "c",
    "definition": "sparsevec_cmp",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_cmp(sparsevec, sparsevec)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_cmp$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, sparsevec",
    "identity_argument_types": "sparsevec, sparsevec",
    "return_type_id": 23,
    "return_type": "integer",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18013,
    "schema": "public",
    "name": "sparsevec_l2_squared_distance",
    "language": "c",
    "definition": "sparsevec_l2_squared_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_l2_squared_distance(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_l2_squared_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, sparsevec",
    "identity_argument_types": "sparsevec, sparsevec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18014,
    "schema": "public",
    "name": "sparsevec_negative_inner_product",
    "language": "c",
    "definition": "sparsevec_negative_inner_product",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_negative_inner_product(sparsevec, sparsevec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_negative_inner_product$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, sparsevec",
    "identity_argument_types": "sparsevec, sparsevec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18015,
    "schema": "public",
    "name": "sparsevec",
    "language": "c",
    "definition": "sparsevec",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec(sparsevec, integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, integer, boolean",
    "identity_argument_types": "sparsevec, integer, boolean",
    "return_type_id": 17993,
    "return_type": "sparsevec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18016,
    "schema": "public",
    "name": "vector_to_sparsevec",
    "language": "c",
    "definition": "vector_to_sparsevec",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_to_sparsevec(vector, integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_to_sparsevec$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "vector, integer, boolean",
    "identity_argument_types": "vector, integer, boolean",
    "return_type_id": 17993,
    "return_type": "sparsevec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18017,
    "schema": "public",
    "name": "sparsevec_to_vector",
    "language": "c",
    "definition": "sparsevec_to_vector",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_to_vector(sparsevec, integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_to_vector$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, integer, boolean",
    "identity_argument_types": "sparsevec, integer, boolean",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18018,
    "schema": "public",
    "name": "halfvec_to_sparsevec",
    "language": "c",
    "definition": "halfvec_to_sparsevec",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_to_sparsevec(halfvec, integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_to_sparsevec$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, integer, boolean",
    "identity_argument_types": "halfvec, integer, boolean",
    "return_type_id": 17993,
    "return_type": "sparsevec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18019,
    "schema": "public",
    "name": "sparsevec_to_halfvec",
    "language": "c",
    "definition": "sparsevec_to_halfvec",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.sparsevec_to_halfvec(sparsevec, integer, boolean)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$sparsevec_to_halfvec$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17993,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "sparsevec, integer, boolean",
    "identity_argument_types": "sparsevec, integer, boolean",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18020,
    "schema": "public",
    "name": "array_to_sparsevec",
    "language": "c",
    "definition": "array_to_sparsevec",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.array_to_sparsevec(integer[], integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_sparsevec$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1007,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "integer[], integer, boolean",
    "identity_argument_types": "integer[], integer, boolean",
    "return_type_id": 17993,
    "return_type": "sparsevec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18021,
    "schema": "public",
    "name": "array_to_sparsevec",
    "language": "c",
    "definition": "array_to_sparsevec",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.array_to_sparsevec(real[], integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_sparsevec$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1021,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "real[], integer, boolean",
    "identity_argument_types": "real[], integer, boolean",
    "return_type_id": 17993,
    "return_type": "sparsevec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18022,
    "schema": "public",
    "name": "array_to_sparsevec",
    "language": "c",
    "definition": "array_to_sparsevec",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.array_to_sparsevec(double precision[], integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_sparsevec$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1022,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "double precision[], integer, boolean",
    "identity_argument_types": "double precision[], integer, boolean",
    "return_type_id": 17993,
    "return_type": "sparsevec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 18023,
    "schema": "public",
    "name": "array_to_sparsevec",
    "language": "c",
    "definition": "array_to_sparsevec",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.array_to_sparsevec(numeric[], integer, boolean)\n RETURNS sparsevec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_sparsevec$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1231,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "numeric[], integer, boolean",
    "identity_argument_types": "numeric[], integer, boolean",
    "return_type_id": 17993,
    "return_type": "sparsevec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17213,
    "schema": "realtime",
    "name": "is_visible_through_filters",
    "language": "sql",
    "definition": "\n    /*\n    Should the record be visible (true) or filtered out (false) after *filters* are applied\n    */\n        select\n            -- Default to allowed when no filters present\n            $2 is null -- no filters. this should not happen because subscriptions has a default\n            or array_length($2, 1) is null -- array length of an empty array is null\n            or bool_and(\n                coalesce(\n                    realtime.check_equality_op(\n                        op:=f.op,\n                        type_:=coalesce(\n                            col.type_oid::regtype, -- null when wal2json version <= 2.4\n                            col.type_name::regtype\n                        ),\n                        -- cast jsonb to text\n                        val_1:=col.value #>> '{}',\n                        val_2:=f.value\n                    ),\n                    false -- if null, filter does not match\n                )\n            )\n        from\n            unnest(filters) f\n            join unnest(columns) col\n                on f.column_name = col.name;\n    ",
    "complete_statement": "CREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    Should the record be visible (true) or filtered out (false) after *filters* are applied\n    */\n        select\n            -- Default to allowed when no filters present\n            $2 is null -- no filters. this should not happen because subscriptions has a default\n            or array_length($2, 1) is null -- array length of an empty array is null\n            or bool_and(\n                coalesce(\n                    realtime.check_equality_op(\n                        op:=f.op,\n                        type_:=coalesce(\n                            col.type_oid::regtype, -- null when wal2json version <= 2.4\n                            col.type_name::regtype\n                        ),\n                        -- cast jsonb to text\n                        val_1:=col.value #>> '{}',\n                        val_2:=f.value\n                    ),\n                    false -- if null, filter does not match\n                )\n            )\n        from\n            unnest(filters) f\n            join unnest(columns) col\n                on f.column_name = col.name;\n    $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "columns",
        "type_id": 17211,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "filters",
        "type_id": 17144,
        "has_default": false
      }
    ],
    "argument_types": "columns realtime.wal_column[], filters realtime.user_defined_filter[]",
    "identity_argument_types": "columns realtime.wal_column[], filters realtime.user_defined_filter[]",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17062,
    "schema": "supabase_functions",
    "name": "http_request",
    "language": "plpgsql",
    "definition": "\n  DECLARE\n    request_id bigint;\n    payload jsonb;\n    url text := TG_ARGV[0]::text;\n    method text := TG_ARGV[1]::text;\n    headers jsonb DEFAULT '{}'::jsonb;\n    params jsonb DEFAULT '{}'::jsonb;\n    timeout_ms integer DEFAULT 1000;\n  BEGIN\n    IF url IS NULL OR url = 'null' THEN\n      RAISE EXCEPTION 'url argument is missing';\n    END IF;\n\n    IF method IS NULL OR method = 'null' THEN\n      RAISE EXCEPTION 'method argument is missing';\n    END IF;\n\n    IF TG_ARGV[2] IS NULL OR TG_ARGV[2] = 'null' THEN\n      headers = '{\"Content-Type\": \"application/json\"}'::jsonb;\n    ELSE\n      headers = TG_ARGV[2]::jsonb;\n    END IF;\n\n    IF TG_ARGV[3] IS NULL OR TG_ARGV[3] = 'null' THEN\n      params = '{}'::jsonb;\n    ELSE\n      params = TG_ARGV[3]::jsonb;\n    END IF;\n\n    IF TG_ARGV[4] IS NULL OR TG_ARGV[4] = 'null' THEN\n      timeout_ms = 1000;\n    ELSE\n      timeout_ms = TG_ARGV[4]::integer;\n    END IF;\n\n    CASE\n      WHEN method = 'GET' THEN\n        SELECT http_get INTO request_id FROM net.http_get(\n          url,\n          params,\n          headers,\n          timeout_ms\n        );\n      WHEN method = 'POST' THEN\n        payload = jsonb_build_object(\n          'old_record', OLD,\n          'record', NEW,\n          'type', TG_OP,\n          'table', TG_TABLE_NAME,\n          'schema', TG_TABLE_SCHEMA\n        );\n\n        SELECT http_post INTO request_id FROM net.http_post(\n          url,\n          payload,\n          params,\n          headers,\n          timeout_ms\n        );\n      ELSE\n        RAISE EXCEPTION 'method argument % is invalid', method;\n    END CASE;\n\n    INSERT INTO supabase_functions.hooks\n      (hook_table_id, hook_name, request_id)\n    VALUES\n      (TG_RELID, TG_NAME, request_id);\n\n    RETURN NEW;\n  END\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION supabase_functions.http_request()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'supabase_functions'\nAS $function$\n  DECLARE\n    request_id bigint;\n    payload jsonb;\n    url text := TG_ARGV[0]::text;\n    method text := TG_ARGV[1]::text;\n    headers jsonb DEFAULT '{}'::jsonb;\n    params jsonb DEFAULT '{}'::jsonb;\n    timeout_ms integer DEFAULT 1000;\n  BEGIN\n    IF url IS NULL OR url = 'null' THEN\n      RAISE EXCEPTION 'url argument is missing';\n    END IF;\n\n    IF method IS NULL OR method = 'null' THEN\n      RAISE EXCEPTION 'method argument is missing';\n    END IF;\n\n    IF TG_ARGV[2] IS NULL OR TG_ARGV[2] = 'null' THEN\n      headers = '{\"Content-Type\": \"application/json\"}'::jsonb;\n    ELSE\n      headers = TG_ARGV[2]::jsonb;\n    END IF;\n\n    IF TG_ARGV[3] IS NULL OR TG_ARGV[3] = 'null' THEN\n      params = '{}'::jsonb;\n    ELSE\n      params = TG_ARGV[3]::jsonb;\n    END IF;\n\n    IF TG_ARGV[4] IS NULL OR TG_ARGV[4] = 'null' THEN\n      timeout_ms = 1000;\n    ELSE\n      timeout_ms = TG_ARGV[4]::integer;\n    END IF;\n\n    CASE\n      WHEN method = 'GET' THEN\n        SELECT http_get INTO request_id FROM net.http_get(\n          url,\n          params,\n          headers,\n          timeout_ms\n        );\n      WHEN method = 'POST' THEN\n        payload = jsonb_build_object(\n          'old_record', OLD,\n          'record', NEW,\n          'type', TG_OP,\n          'table', TG_TABLE_NAME,\n          'schema', TG_TABLE_SCHEMA\n        );\n\n        SELECT http_post INTO request_id FROM net.http_post(\n          url,\n          payload,\n          params,\n          headers,\n          timeout_ms\n        );\n      ELSE\n        RAISE EXCEPTION 'method argument % is invalid', method;\n    END CASE;\n\n    INSERT INTO supabase_functions.hooks\n      (hook_table_id, hook_name, request_id)\n    VALUES\n      (TG_RELID, TG_NAME, request_id);\n\n    RETURN NEW;\n  END\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2279,
    "return_type": "trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": {
      "search_path": "supabase_functions"
    }
  },
  {
    "id": 17224,
    "schema": "realtime",
    "name": "list_changes",
    "language": "sql",
    "definition": "\n      with pub as (\n        select\n          concat_ws(\n            ',',\n            case when bool_or(pubinsert) then 'insert' else null end,\n            case when bool_or(pubupdate) then 'update' else null end,\n            case when bool_or(pubdelete) then 'delete' else null end\n          ) as w2j_actions,\n          coalesce(\n            string_agg(\n              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),\n              ','\n            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),\n            ''\n          ) w2j_add_tables\n        from\n          pg_publication pp\n          left join pg_publication_tables ppt\n            on pp.pubname = ppt.pubname\n        where\n          pp.pubname = publication\n        group by\n          pp.pubname\n        limit 1\n      ),\n      w2j as (\n        select\n          x.*, pub.w2j_add_tables\n        from\n          pub,\n          pg_logical_slot_get_changes(\n            slot_name, null, max_changes,\n            'include-pk', 'true',\n            'include-transaction', 'false',\n            'include-timestamp', 'true',\n            'include-type-oids', 'true',\n            'format-version', '2',\n            'actions', pub.w2j_actions,\n            'add-tables', pub.w2j_add_tables\n          ) x\n      )\n      select\n        xyz.wal,\n        xyz.is_rls_enabled,\n        xyz.subscription_ids,\n        xyz.errors\n      from\n        w2j,\n        realtime.apply_rls(\n          wal := w2j.data::jsonb,\n          max_record_bytes := max_record_bytes\n        ) xyz(wal, is_rls_enabled, subscription_ids, errors)\n      where\n        w2j.w2j_add_tables <> ''\n        and xyz.subscription_ids[1] is not null\n    ",
    "complete_statement": "CREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)\n RETURNS SETOF realtime.wal_rls\n LANGUAGE sql\n SET log_min_messages TO 'fatal'\nAS $function$\n      with pub as (\n        select\n          concat_ws(\n            ',',\n            case when bool_or(pubinsert) then 'insert' else null end,\n            case when bool_or(pubupdate) then 'update' else null end,\n            case when bool_or(pubdelete) then 'delete' else null end\n          ) as w2j_actions,\n          coalesce(\n            string_agg(\n              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),\n              ','\n            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),\n            ''\n          ) w2j_add_tables\n        from\n          pg_publication pp\n          left join pg_publication_tables ppt\n            on pp.pubname = ppt.pubname\n        where\n          pp.pubname = publication\n        group by\n          pp.pubname\n        limit 1\n      ),\n      w2j as (\n        select\n          x.*, pub.w2j_add_tables\n        from\n          pub,\n          pg_logical_slot_get_changes(\n            slot_name, null, max_changes,\n            'include-pk', 'true',\n            'include-transaction', 'false',\n            'include-timestamp', 'true',\n            'include-type-oids', 'true',\n            'format-version', '2',\n            'actions', pub.w2j_actions,\n            'add-tables', pub.w2j_add_tables\n          ) x\n      )\n      select\n        xyz.wal,\n        xyz.is_rls_enabled,\n        xyz.subscription_ids,\n        xyz.errors\n      from\n        w2j,\n        realtime.apply_rls(\n          wal := w2j.data::jsonb,\n          max_record_bytes := max_record_bytes\n        ) xyz(wal, is_rls_enabled, subscription_ids, errors)\n      where\n        w2j.w2j_add_tables <> ''\n        and xyz.subscription_ids[1] is not null\n    $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "publication",
        "type_id": 19,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "slot_name",
        "type_id": 19,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "max_changes",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "max_record_bytes",
        "type_id": 23,
        "has_default": false
      }
    ],
    "argument_types": "publication name, slot_name name, max_changes integer, max_record_bytes integer",
    "identity_argument_types": "publication name, slot_name name, max_changes integer, max_record_bytes integer",
    "return_type_id": 17183,
    "return_type": "SETOF realtime.wal_rls",
    "return_type_relation_id": 17181,
    "is_set_returning_function": true,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": {
      "log_min_messages": "fatal"
    }
  },
  {
    "id": 17019,
    "schema": "net",
    "name": "http_get",
    "language": "plpgsql",
    "definition": "\ndeclare\n    request_id bigint;\n    params_array text[];\nbegin\n    select coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into params_array\n    from jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, timeout_milliseconds)\n    values (\n        'GET',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION net.http_get(url text, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{}'::jsonb, timeout_milliseconds integer DEFAULT 5000)\n RETURNS bigint\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT SECURITY DEFINER\n SET search_path TO 'net'\nAS $function$\ndeclare\n    request_id bigint;\n    params_array text[];\nbegin\n    select coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into params_array\n    from jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, timeout_milliseconds)\n    values (\n        'GET',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "url",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "params",
        "type_id": 3802,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "headers",
        "type_id": 3802,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "timeout_milliseconds",
        "type_id": 23,
        "has_default": true
      }
    ],
    "argument_types": "url text, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{}'::jsonb, timeout_milliseconds integer DEFAULT 5000",
    "identity_argument_types": "url text, params jsonb, headers jsonb, timeout_milliseconds integer",
    "return_type_id": 20,
    "return_type": "bigint",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": {
      "search_path": "net"
    }
  },
  {
    "id": 17020,
    "schema": "net",
    "name": "http_post",
    "language": "plpgsql",
    "definition": "\ndeclare\n    request_id bigint;\n    params_array text[];\n    content_type text;\nbegin\n\n    -- Exctract the content_type from headers\n    select\n        header_value into content_type\n    from\n        jsonb_each_text(coalesce(headers, '{}'::jsonb)) r(header_name, header_value)\n    where\n        lower(header_name) = 'content-type'\n    limit\n        1;\n\n    -- If the user provided new headers and omitted the content type\n    -- add it back in automatically\n    if content_type is null then\n        select headers || '{\"Content-Type\": \"application/json\"}'::jsonb into headers;\n    end if;\n\n    -- Confirm that the content-type is set as \"application/json\"\n    if content_type <> 'application/json' then\n        raise exception 'Content-Type header must be \"application/json\"';\n    end if;\n\n    select\n        coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into\n        params_array\n    from\n        jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, body, timeout_milliseconds)\n    values (\n        'POST',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        convert_to(body::text, 'UTF8'),\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION net.http_post(url text, body jsonb DEFAULT '{}'::jsonb, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{\"Content-Type\": \"application/json\"}'::jsonb, timeout_milliseconds integer DEFAULT 5000)\n RETURNS bigint\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'net'\nAS $function$\ndeclare\n    request_id bigint;\n    params_array text[];\n    content_type text;\nbegin\n\n    -- Exctract the content_type from headers\n    select\n        header_value into content_type\n    from\n        jsonb_each_text(coalesce(headers, '{}'::jsonb)) r(header_name, header_value)\n    where\n        lower(header_name) = 'content-type'\n    limit\n        1;\n\n    -- If the user provided new headers and omitted the content type\n    -- add it back in automatically\n    if content_type is null then\n        select headers || '{\"Content-Type\": \"application/json\"}'::jsonb into headers;\n    end if;\n\n    -- Confirm that the content-type is set as \"application/json\"\n    if content_type <> 'application/json' then\n        raise exception 'Content-Type header must be \"application/json\"';\n    end if;\n\n    select\n        coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into\n        params_array\n    from\n        jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, body, timeout_milliseconds)\n    values (\n        'POST',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        convert_to(body::text, 'UTF8'),\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "url",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "body",
        "type_id": 3802,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "params",
        "type_id": 3802,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "headers",
        "type_id": 3802,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "timeout_milliseconds",
        "type_id": 23,
        "has_default": true
      }
    ],
    "argument_types": "url text, body jsonb DEFAULT '{}'::jsonb, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{\"Content-Type\": \"application/json\"}'::jsonb, timeout_milliseconds integer DEFAULT 5000",
    "identity_argument_types": "url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer",
    "return_type_id": 20,
    "return_type": "bigint",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": {
      "search_path": "net"
    }
  },
  {
    "id": 17756,
    "schema": "public",
    "name": "vector_dims",
    "language": "c",
    "definition": "vector_dims",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_dims(vector)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_dims$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector",
    "identity_argument_types": "vector",
    "return_type_id": 23,
    "return_type": "integer",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17757,
    "schema": "public",
    "name": "vector_norm",
    "language": "c",
    "definition": "vector_norm",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_norm(vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_norm$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector",
    "identity_argument_types": "vector",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17758,
    "schema": "public",
    "name": "l2_normalize",
    "language": "c",
    "definition": "l2_normalize",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.l2_normalize(vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$l2_normalize$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector",
    "identity_argument_types": "vector",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17759,
    "schema": "public",
    "name": "binary_quantize",
    "language": "c",
    "definition": "binary_quantize",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.binary_quantize(vector)\n RETURNS bit\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$binary_quantize$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector",
    "identity_argument_types": "vector",
    "return_type_id": 1560,
    "return_type": "bit",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17760,
    "schema": "public",
    "name": "subvector",
    "language": "c",
    "definition": "subvector",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.subvector(vector, integer, integer)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$subvector$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      }
    ],
    "argument_types": "vector, integer, integer",
    "identity_argument_types": "vector, integer, integer",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17761,
    "schema": "public",
    "name": "vector_add",
    "language": "c",
    "definition": "vector_add",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_add(vector, vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_add$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17762,
    "schema": "public",
    "name": "vector_sub",
    "language": "c",
    "definition": "vector_sub",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_sub(vector, vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_sub$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17763,
    "schema": "public",
    "name": "vector_mul",
    "language": "c",
    "definition": "vector_mul",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_mul(vector, vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_mul$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17764,
    "schema": "public",
    "name": "vector_concat",
    "language": "c",
    "definition": "vector_concat",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_concat(vector, vector)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_concat$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17765,
    "schema": "public",
    "name": "vector_lt",
    "language": "c",
    "definition": "vector_lt",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_lt(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_lt$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17766,
    "schema": "public",
    "name": "vector_le",
    "language": "c",
    "definition": "vector_le",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_le(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_le$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17767,
    "schema": "public",
    "name": "vector_eq",
    "language": "c",
    "definition": "vector_eq",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_eq(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_eq$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17768,
    "schema": "public",
    "name": "vector_ne",
    "language": "c",
    "definition": "vector_ne",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_ne(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_ne$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17769,
    "schema": "public",
    "name": "vector_ge",
    "language": "c",
    "definition": "vector_ge",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_ge(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_ge$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17770,
    "schema": "public",
    "name": "vector_gt",
    "language": "c",
    "definition": "vector_gt",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_gt(vector, vector)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_gt$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17161,
    "schema": "realtime",
    "name": "quote_wal2json",
    "language": "sql",
    "definition": "\n      select\n        (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n        )\n        || '.'\n        || (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n          )\n      from\n        pg_class pc\n        join pg_namespace nsp\n          on pc.relnamespace = nsp.oid\n      where\n        pc.oid = entity\n    ",
    "complete_statement": "CREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\n      select\n        (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n        )\n        || '.'\n        || (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n          )\n      from\n        pg_class pc\n        join pg_namespace nsp\n          on pc.relnamespace = nsp.oid\n      where\n        pc.oid = entity\n    $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "entity",
        "type_id": 2205,
        "has_default": false
      }
    ],
    "argument_types": "entity regclass",
    "identity_argument_types": "entity regclass",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17776,
    "schema": "public",
    "name": "vector_avg",
    "language": "c",
    "definition": "vector_avg",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_avg(double precision[])\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_avg$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1022,
        "has_default": false
      }
    ],
    "argument_types": "double precision[]",
    "identity_argument_types": "double precision[]",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17777,
    "schema": "public",
    "name": "vector_combine",
    "language": "c",
    "definition": "vector_combine",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_combine(double precision[], double precision[])\n RETURNS double precision[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_combine$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1022,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 1022,
        "has_default": false
      }
    ],
    "argument_types": "double precision[], double precision[]",
    "identity_argument_types": "double precision[], double precision[]",
    "return_type_id": 1022,
    "return_type": "double precision[]",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17167,
    "schema": "realtime",
    "name": "cast",
    "language": "plpgsql",
    "definition": "\n    declare\n      res jsonb;\n    begin\n      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;\n      return res;\n    end\n    ",
    "complete_statement": "CREATE OR REPLACE FUNCTION realtime.\"cast\"(val text, type_ regtype)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n    declare\n      res jsonb;\n    begin\n      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;\n      return res;\n    end\n    $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "val",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "type_",
        "type_id": 2206,
        "has_default": false
      }
    ],
    "argument_types": "val text, type_ regtype",
    "identity_argument_types": "val text, type_ regtype",
    "return_type_id": 3802,
    "return_type": "jsonb",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17162,
    "schema": "realtime",
    "name": "check_equality_op",
    "language": "plpgsql",
    "definition": "\n      /*\n      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness\n      */\n      declare\n          op_symbol text = (\n              case\n                  when op = 'eq' then '='\n                  when op = 'neq' then '!='\n                  when op = 'lt' then '<'\n                  when op = 'lte' then '<='\n                  when op = 'gt' then '>'\n                  when op = 'gte' then '>='\n                  when op = 'in' then '= any'\n                  else 'UNKNOWN OP'\n              end\n          );\n          res boolean;\n      begin\n          execute format(\n              'select %L::'|| type_::text || ' ' || op_symbol\n              || ' ( %L::'\n              || (\n                  case\n                      when op = 'in' then type_::text || '[]'\n                      else type_::text end\n              )\n              || ')', val_1, val_2) into res;\n          return res;\n      end;\n      ",
    "complete_statement": "CREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)\n RETURNS boolean\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n      /*\n      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness\n      */\n      declare\n          op_symbol text = (\n              case\n                  when op = 'eq' then '='\n                  when op = 'neq' then '!='\n                  when op = 'lt' then '<'\n                  when op = 'lte' then '<='\n                  when op = 'gt' then '>'\n                  when op = 'gte' then '>='\n                  when op = 'in' then '= any'\n                  else 'UNKNOWN OP'\n              end\n          );\n          res boolean;\n      begin\n          execute format(\n              'select %L::'|| type_::text || ' ' || op_symbol\n              || ' ( %L::'\n              || (\n                  case\n                      when op = 'in' then type_::text || '[]'\n                      else type_::text end\n              )\n              || ')', val_1, val_2) into res;\n          return res;\n      end;\n      $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "op",
        "type_id": 17131,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "type_",
        "type_id": 2206,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "val_1",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "val_2",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "op realtime.equality_op, type_ regtype, val_1 text, val_2 text",
    "identity_argument_types": "op realtime.equality_op, type_ regtype, val_1 text, val_2 text",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17771,
    "schema": "public",
    "name": "vector_cmp",
    "language": "c",
    "definition": "vector_cmp",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_cmp(vector, vector)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_cmp$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 23,
    "return_type": "integer",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17772,
    "schema": "public",
    "name": "vector_l2_squared_distance",
    "language": "c",
    "definition": "vector_l2_squared_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_l2_squared_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_l2_squared_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17773,
    "schema": "public",
    "name": "vector_negative_inner_product",
    "language": "c",
    "definition": "vector_negative_inner_product",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_negative_inner_product(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_negative_inner_product$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17774,
    "schema": "public",
    "name": "vector_spherical_distance",
    "language": "c",
    "definition": "vector_spherical_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_spherical_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_spherical_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17775,
    "schema": "public",
    "name": "vector_accum",
    "language": "c",
    "definition": "vector_accum",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_accum(double precision[], vector)\n RETURNS double precision[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_accum$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1022,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "double precision[], vector",
    "identity_argument_types": "double precision[], vector",
    "return_type_id": 1022,
    "return_type": "double precision[]",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17780,
    "schema": "public",
    "name": "vector",
    "language": "c",
    "definition": "vector",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector(vector, integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "vector, integer, boolean",
    "identity_argument_types": "vector, integer, boolean",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17781,
    "schema": "public",
    "name": "array_to_vector",
    "language": "c",
    "definition": "array_to_vector",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.array_to_vector(integer[], integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_vector$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1007,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "integer[], integer, boolean",
    "identity_argument_types": "integer[], integer, boolean",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17782,
    "schema": "public",
    "name": "array_to_vector",
    "language": "c",
    "definition": "array_to_vector",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.array_to_vector(real[], integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_vector$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1021,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "real[], integer, boolean",
    "identity_argument_types": "real[], integer, boolean",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17783,
    "schema": "public",
    "name": "array_to_vector",
    "language": "c",
    "definition": "array_to_vector",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.array_to_vector(double precision[], integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_vector$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1022,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "double precision[], integer, boolean",
    "identity_argument_types": "double precision[], integer, boolean",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17784,
    "schema": "public",
    "name": "array_to_vector",
    "language": "c",
    "definition": "array_to_vector",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.array_to_vector(numeric[], integer, boolean)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$array_to_vector$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1231,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "numeric[], integer, boolean",
    "identity_argument_types": "numeric[], integer, boolean",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17785,
    "schema": "public",
    "name": "vector_to_float4",
    "language": "c",
    "definition": "vector_to_float4",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_to_float4(vector, integer, boolean)\n RETURNS real[]\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_to_float4$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 16,
        "has_default": false
      }
    ],
    "argument_types": "vector, integer, boolean",
    "identity_argument_types": "vector, integer, boolean",
    "return_type_id": 1021,
    "return_type": "real[]",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17806,
    "schema": "public",
    "name": "ivfflathandler",
    "language": "c",
    "definition": "ivfflathandler",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.ivfflathandler(internal)\n RETURNS index_am_handler\n LANGUAGE c\nAS '$libdir/vector', $function$ivfflathandler$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 2281,
        "has_default": false
      }
    ],
    "argument_types": "internal",
    "identity_argument_types": "internal",
    "return_type_id": 325,
    "return_type": "index_am_handler",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17808,
    "schema": "public",
    "name": "hnswhandler",
    "language": "c",
    "definition": "hnswhandler",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.hnswhandler(internal)\n RETURNS index_am_handler\n LANGUAGE c\nAS '$libdir/vector', $function$hnswhandler$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 2281,
        "has_default": false
      }
    ],
    "argument_types": "internal",
    "identity_argument_types": "internal",
    "return_type_id": 325,
    "return_type": "index_am_handler",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17810,
    "schema": "public",
    "name": "ivfflat_halfvec_support",
    "language": "c",
    "definition": "ivfflat_halfvec_support",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.ivfflat_halfvec_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$ivfflat_halfvec_support$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 2281,
        "has_default": false
      }
    ],
    "argument_types": "internal",
    "identity_argument_types": "internal",
    "return_type_id": 2281,
    "return_type": "internal",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17811,
    "schema": "public",
    "name": "ivfflat_bit_support",
    "language": "c",
    "definition": "ivfflat_bit_support",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.ivfflat_bit_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$ivfflat_bit_support$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 2281,
        "has_default": false
      }
    ],
    "argument_types": "internal",
    "identity_argument_types": "internal",
    "return_type_id": 2281,
    "return_type": "internal",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17194,
    "schema": "realtime",
    "name": "to_regrole",
    "language": "sql",
    "definition": " select role_name::regrole ",
    "complete_statement": "CREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)\n RETURNS regrole\n LANGUAGE sql\n IMMUTABLE\nAS $function$ select role_name::regrole $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "role_name",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "role_name text",
    "identity_argument_types": "role_name text",
    "return_type_id": 4096,
    "return_type": "regrole",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17812,
    "schema": "public",
    "name": "hnsw_halfvec_support",
    "language": "c",
    "definition": "hnsw_halfvec_support",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.hnsw_halfvec_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$hnsw_halfvec_support$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 2281,
        "has_default": false
      }
    ],
    "argument_types": "internal",
    "identity_argument_types": "internal",
    "return_type_id": 2281,
    "return_type": "internal",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17813,
    "schema": "public",
    "name": "hnsw_bit_support",
    "language": "c",
    "definition": "hnsw_bit_support",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.hnsw_bit_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$hnsw_bit_support$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 2281,
        "has_default": false
      }
    ],
    "argument_types": "internal",
    "identity_argument_types": "internal",
    "return_type_id": 2281,
    "return_type": "internal",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17217,
    "schema": "realtime",
    "name": "build_prepared_statement_sql",
    "language": "sql",
    "definition": "\n      /*\n      Builds a sql string that, if executed, creates a prepared statement to\n      tests retrive a row from *entity* by its primary key columns.\n      Example\n          select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])\n      */\n          select\n      'prepare ' || prepared_statement_name || ' as\n          select\n              exists(\n                  select\n                      1\n                  from\n                      ' || entity || '\n                  where\n                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '\n              )'\n          from\n              unnest(columns) pkc\n          where\n              pkc.is_pkey\n          group by\n              entity\n      ",
    "complete_statement": "CREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])\n RETURNS text\n LANGUAGE sql\nAS $function$\n      /*\n      Builds a sql string that, if executed, creates a prepared statement to\n      tests retrive a row from *entity* by its primary key columns.\n      Example\n          select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])\n      */\n          select\n      'prepare ' || prepared_statement_name || ' as\n          select\n              exists(\n                  select\n                      1\n                  from\n                      ' || entity || '\n                  where\n                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '\n              )'\n          from\n              unnest(columns) pkc\n          where\n              pkc.is_pkey\n          group by\n              entity\n      $function$\n",
    "args": [
      {
        "mode": "in",
        "name": "prepared_statement_name",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "entity",
        "type_id": 2205,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "columns",
        "type_id": 17211,
        "has_default": false
      }
    ],
    "argument_types": "prepared_statement_name text, entity regclass, columns realtime.wal_column[]",
    "identity_argument_types": "prepared_statement_name text, entity regclass, columns realtime.wal_column[]",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17814,
    "schema": "public",
    "name": "hnsw_sparsevec_support",
    "language": "c",
    "definition": "hnsw_sparsevec_support",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.hnsw_sparsevec_support(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/vector', $function$hnsw_sparsevec_support$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 2281,
        "has_default": false
      }
    ],
    "argument_types": "internal",
    "identity_argument_types": "internal",
    "return_type_id": 2281,
    "return_type": "internal",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17859,
    "schema": "public",
    "name": "halfvec_in",
    "language": "c",
    "definition": "halfvec_in",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_in(cstring, oid, integer)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_in$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 2275,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 26,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      }
    ],
    "argument_types": "cstring, oid, integer",
    "identity_argument_types": "cstring, oid, integer",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17205,
    "schema": "realtime",
    "name": "apply_rls",
    "language": "plpgsql",
    "definition": "\ndeclare\n-- Regclass of the table e.g. public.notes\nentity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n-- I, U, D, T: insert, update ...\naction realtime.action = (\n    case wal ->> 'action'\n        when 'I' then 'INSERT'\n        when 'U' then 'UPDATE'\n        when 'D' then 'DELETE'\n        else 'ERROR'\n    end\n);\n\n-- Is row level security enabled for the table\nis_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\nsubscriptions realtime.subscription[] = array_agg(subs)\n    from\n        realtime.subscription subs\n    where\n        subs.entity = entity_;\n\n-- Subscription vars\nroles regrole[] = array_agg(distinct us.claims_role::text)\n    from\n        unnest(subscriptions) us;\n\nworking_role regrole;\nclaimed_role regrole;\nclaims jsonb;\n\nsubscription_id uuid;\nsubscription_has_access bool;\nvisible_to_subscription_ids uuid[] = '{}';\n\n-- structured info for wal's columns\ncolumns realtime.wal_column[];\n-- previous identity values for update/delete\nold_columns realtime.wal_column[];\n\nerror_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;\n\n-- Primary jsonb output for record\noutput jsonb;\n\nbegin\nperform set_config('role', null, true);\n\ncolumns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'columns') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nold_columns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'identity') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nfor working_role in select * from unnest(roles) loop\n\n    -- Update `is_selectable` for columns and old_columns\n    columns =\n        array_agg(\n            (\n                c.name,\n                c.type_name,\n                c.type_oid,\n                c.value,\n                c.is_pkey,\n                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n            )::realtime.wal_column\n        )\n        from\n            unnest(columns) c;\n\n    old_columns =\n            array_agg(\n                (\n                    c.name,\n                    c.type_name,\n                    c.type_oid,\n                    c.value,\n                    c.is_pkey,\n                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                )::realtime.wal_column\n            )\n            from\n                unnest(old_columns) c;\n\n    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            -- subscriptions is already filtered by entity\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 400: Bad Request, no primary key']\n        )::realtime.wal_rls;\n\n    -- The claims role does not have SELECT permission to the primary key of entity\n    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 401: Unauthorized']\n        )::realtime.wal_rls;\n\n    else\n        output = jsonb_build_object(\n            'schema', wal ->> 'schema',\n            'table', wal ->> 'table',\n            'type', action,\n            'commit_timestamp', to_char(\n                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),\n                'YYYY-MM-DD\"T\"HH24:MI:SS.MS\"Z\"'\n            ),\n            'columns', (\n                select\n                    jsonb_agg(\n                        jsonb_build_object(\n                            'name', pa.attname,\n                            'type', pt.typname\n                        )\n                        order by pa.attnum asc\n                    )\n                from\n                    pg_attribute pa\n                    join pg_type pt\n                        on pa.atttypid = pt.oid\n                where\n                    attrelid = entity_\n                    and attnum > 0\n                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')\n            )\n        )\n        -- Add \"record\" key for insert and update\n        || case\n            when action in ('INSERT', 'UPDATE') then\n                jsonb_build_object(\n                    'record',\n                    (\n                        select\n                            jsonb_object_agg(\n                                -- if unchanged toast, get column name and value from old record\n                                coalesce((c).name, (oc).name),\n                                case\n                                    when (c).name is null then (oc).value\n                                    else (c).value\n                                end\n                            )\n                        from\n                            unnest(columns) c\n                            full outer join unnest(old_columns) oc\n                                on (c).name = (oc).name\n                        where\n                            coalesce((c).is_selectable, (oc).is_selectable)\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                    )\n                )\n            else '{}'::jsonb\n        end\n        -- Add \"old_record\" key for update and delete\n        || case\n            when action = 'UPDATE' then\n                jsonb_build_object(\n                        'old_record',\n                        (\n                            select jsonb_object_agg((c).name, (c).value)\n                            from unnest(old_columns) c\n                            where\n                                (c).is_selectable\n                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                        )\n                    )\n            when action = 'DELETE' then\n                jsonb_build_object(\n                    'old_record',\n                    (\n                        select jsonb_object_agg((c).name, (c).value)\n                        from unnest(old_columns) c\n                        where\n                            (c).is_selectable\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey\n                    )\n                )\n            else '{}'::jsonb\n        end;\n\n        -- Create the prepared statement\n        if is_rls_enabled and action <> 'DELETE' then\n            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then\n                deallocate walrus_rls_stmt;\n            end if;\n            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);\n        end if;\n\n        visible_to_subscription_ids = '{}';\n\n        for subscription_id, claims in (\n                select\n                    subs.subscription_id,\n                    subs.claims\n                from\n                    unnest(subscriptions) subs\n                where\n                    subs.entity = entity_\n                    and subs.claims_role = working_role\n                    and (\n                        realtime.is_visible_through_filters(columns, subs.filters)\n                        or (\n                          action = 'DELETE'\n                          and realtime.is_visible_through_filters(old_columns, subs.filters)\n                        )\n                    )\n        ) loop\n\n            if not is_rls_enabled or action = 'DELETE' then\n                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n            else\n                -- Check if RLS allows the role to see the record\n                perform\n                    -- Trim leading and trailing quotes from working_role because set_config\n                    -- doesn't recognize the role as valid if they are included\n                    set_config('role', trim(both '\"' from working_role::text), true),\n                    set_config('request.jwt.claims', claims::text, true);\n\n                execute 'execute walrus_rls_stmt' into subscription_has_access;\n\n                if subscription_has_access then\n                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n                end if;\n            end if;\n        end loop;\n\n        perform set_config('role', null, true);\n\n        return next (\n            output,\n            is_rls_enabled,\n            visible_to_subscription_ids,\n            case\n                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']\n                else '{}'\n            end\n        )::realtime.wal_rls;\n\n    end if;\nend loop;\n\nperform set_config('role', null, true);\nend;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))\n RETURNS SETOF realtime.wal_rls\n LANGUAGE plpgsql\nAS $function$\ndeclare\n-- Regclass of the table e.g. public.notes\nentity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n-- I, U, D, T: insert, update ...\naction realtime.action = (\n    case wal ->> 'action'\n        when 'I' then 'INSERT'\n        when 'U' then 'UPDATE'\n        when 'D' then 'DELETE'\n        else 'ERROR'\n    end\n);\n\n-- Is row level security enabled for the table\nis_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\nsubscriptions realtime.subscription[] = array_agg(subs)\n    from\n        realtime.subscription subs\n    where\n        subs.entity = entity_;\n\n-- Subscription vars\nroles regrole[] = array_agg(distinct us.claims_role::text)\n    from\n        unnest(subscriptions) us;\n\nworking_role regrole;\nclaimed_role regrole;\nclaims jsonb;\n\nsubscription_id uuid;\nsubscription_has_access bool;\nvisible_to_subscription_ids uuid[] = '{}';\n\n-- structured info for wal's columns\ncolumns realtime.wal_column[];\n-- previous identity values for update/delete\nold_columns realtime.wal_column[];\n\nerror_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;\n\n-- Primary jsonb output for record\noutput jsonb;\n\nbegin\nperform set_config('role', null, true);\n\ncolumns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'columns') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nold_columns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'identity') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nfor working_role in select * from unnest(roles) loop\n\n    -- Update `is_selectable` for columns and old_columns\n    columns =\n        array_agg(\n            (\n                c.name,\n                c.type_name,\n                c.type_oid,\n                c.value,\n                c.is_pkey,\n                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n            )::realtime.wal_column\n        )\n        from\n            unnest(columns) c;\n\n    old_columns =\n            array_agg(\n                (\n                    c.name,\n                    c.type_name,\n                    c.type_oid,\n                    c.value,\n                    c.is_pkey,\n                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                )::realtime.wal_column\n            )\n            from\n                unnest(old_columns) c;\n\n    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            -- subscriptions is already filtered by entity\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 400: Bad Request, no primary key']\n        )::realtime.wal_rls;\n\n    -- The claims role does not have SELECT permission to the primary key of entity\n    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 401: Unauthorized']\n        )::realtime.wal_rls;\n\n    else\n        output = jsonb_build_object(\n            'schema', wal ->> 'schema',\n            'table', wal ->> 'table',\n            'type', action,\n            'commit_timestamp', to_char(\n                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),\n                'YYYY-MM-DD\"T\"HH24:MI:SS.MS\"Z\"'\n            ),\n            'columns', (\n                select\n                    jsonb_agg(\n                        jsonb_build_object(\n                            'name', pa.attname,\n                            'type', pt.typname\n                        )\n                        order by pa.attnum asc\n                    )\n                from\n                    pg_attribute pa\n                    join pg_type pt\n                        on pa.atttypid = pt.oid\n                where\n                    attrelid = entity_\n                    and attnum > 0\n                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')\n            )\n        )\n        -- Add \"record\" key for insert and update\n        || case\n            when action in ('INSERT', 'UPDATE') then\n                jsonb_build_object(\n                    'record',\n                    (\n                        select\n                            jsonb_object_agg(\n                                -- if unchanged toast, get column name and value from old record\n                                coalesce((c).name, (oc).name),\n                                case\n                                    when (c).name is null then (oc).value\n                                    else (c).value\n                                end\n                            )\n                        from\n                            unnest(columns) c\n                            full outer join unnest(old_columns) oc\n                                on (c).name = (oc).name\n                        where\n                            coalesce((c).is_selectable, (oc).is_selectable)\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                    )\n                )\n            else '{}'::jsonb\n        end\n        -- Add \"old_record\" key for update and delete\n        || case\n            when action = 'UPDATE' then\n                jsonb_build_object(\n                        'old_record',\n                        (\n                            select jsonb_object_agg((c).name, (c).value)\n                            from unnest(old_columns) c\n                            where\n                                (c).is_selectable\n                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                        )\n                    )\n            when action = 'DELETE' then\n                jsonb_build_object(\n                    'old_record',\n                    (\n                        select jsonb_object_agg((c).name, (c).value)\n                        from unnest(old_columns) c\n                        where\n                            (c).is_selectable\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey\n                    )\n                )\n            else '{}'::jsonb\n        end;\n\n        -- Create the prepared statement\n        if is_rls_enabled and action <> 'DELETE' then\n            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then\n                deallocate walrus_rls_stmt;\n            end if;\n            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);\n        end if;\n\n        visible_to_subscription_ids = '{}';\n\n        for subscription_id, claims in (\n                select\n                    subs.subscription_id,\n                    subs.claims\n                from\n                    unnest(subscriptions) subs\n                where\n                    subs.entity = entity_\n                    and subs.claims_role = working_role\n                    and (\n                        realtime.is_visible_through_filters(columns, subs.filters)\n                        or (\n                          action = 'DELETE'\n                          and realtime.is_visible_through_filters(old_columns, subs.filters)\n                        )\n                    )\n        ) loop\n\n            if not is_rls_enabled or action = 'DELETE' then\n                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n            else\n                -- Check if RLS allows the role to see the record\n                perform\n                    -- Trim leading and trailing quotes from working_role because set_config\n                    -- doesn't recognize the role as valid if they are included\n                    set_config('role', trim(both '\"' from working_role::text), true),\n                    set_config('request.jwt.claims', claims::text, true);\n\n                execute 'execute walrus_rls_stmt' into subscription_has_access;\n\n                if subscription_has_access then\n                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n                end if;\n            end if;\n        end loop;\n\n        perform set_config('role', null, true);\n\n        return next (\n            output,\n            is_rls_enabled,\n            visible_to_subscription_ids,\n            case\n                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']\n                else '{}'\n            end\n        )::realtime.wal_rls;\n\n    end if;\nend loop;\n\nperform set_config('role', null, true);\nend;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "wal",
        "type_id": 3802,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "max_record_bytes",
        "type_id": 23,
        "has_default": true
      }
    ],
    "argument_types": "wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024)",
    "identity_argument_types": "wal jsonb, max_record_bytes integer",
    "return_type_id": 17183,
    "return_type": "SETOF realtime.wal_rls",
    "return_type_relation_id": 17181,
    "is_set_returning_function": true,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17860,
    "schema": "public",
    "name": "halfvec_out",
    "language": "c",
    "definition": "halfvec_out",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_out(halfvec)\n RETURNS cstring\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_out$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec",
    "identity_argument_types": "halfvec",
    "return_type_id": 2275,
    "return_type": "cstring",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17861,
    "schema": "public",
    "name": "halfvec_typmod_in",
    "language": "c",
    "definition": "halfvec_typmod_in",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_typmod_in(cstring[])\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_typmod_in$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1263,
        "has_default": false
      }
    ],
    "argument_types": "cstring[]",
    "identity_argument_types": "cstring[]",
    "return_type_id": 23,
    "return_type": "integer",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17862,
    "schema": "public",
    "name": "halfvec_recv",
    "language": "c",
    "definition": "halfvec_recv",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_recv(internal, oid, integer)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_recv$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 2281,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 26,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      }
    ],
    "argument_types": "internal, oid, integer",
    "identity_argument_types": "internal, oid, integer",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17863,
    "schema": "public",
    "name": "halfvec_send",
    "language": "c",
    "definition": "halfvec_send",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_send(halfvec)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_send$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec",
    "identity_argument_types": "halfvec",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17865,
    "schema": "public",
    "name": "l2_distance",
    "language": "c",
    "definition": "halfvec_l2_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.l2_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l2_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17866,
    "schema": "public",
    "name": "inner_product",
    "language": "c",
    "definition": "halfvec_inner_product",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.inner_product(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_inner_product$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17867,
    "schema": "public",
    "name": "cosine_distance",
    "language": "c",
    "definition": "halfvec_cosine_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.cosine_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_cosine_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17868,
    "schema": "public",
    "name": "l1_distance",
    "language": "c",
    "definition": "halfvec_l1_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.l1_distance(halfvec, halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l1_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17869,
    "schema": "public",
    "name": "vector_dims",
    "language": "c",
    "definition": "halfvec_vector_dims",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_dims(halfvec)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_vector_dims$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec",
    "identity_argument_types": "halfvec",
    "return_type_id": 23,
    "return_type": "integer",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17870,
    "schema": "public",
    "name": "l2_norm",
    "language": "c",
    "definition": "halfvec_l2_norm",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.l2_norm(halfvec)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l2_norm$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec",
    "identity_argument_types": "halfvec",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17871,
    "schema": "public",
    "name": "l2_normalize",
    "language": "c",
    "definition": "halfvec_l2_normalize",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.l2_normalize(halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_l2_normalize$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec",
    "identity_argument_types": "halfvec",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17872,
    "schema": "public",
    "name": "binary_quantize",
    "language": "c",
    "definition": "halfvec_binary_quantize",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.binary_quantize(halfvec)\n RETURNS bit\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_binary_quantize$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec",
    "identity_argument_types": "halfvec",
    "return_type_id": 1560,
    "return_type": "bit",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17159,
    "schema": "realtime",
    "name": "subscription_check_filters",
    "language": "plpgsql",
    "definition": "\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity\n                and pg_catalog.has_column_privilege(\n                    (new.claims ->> 'role'),\n                    format('%I.%I', c.table_schema, c.table_name)::regclass,\n                    c.column_name,\n                    'SELECT'\n                );\n        filter realtime.user_defined_filter;\n        col_type regtype;\n\n        in_val jsonb;\n    begin\n        for filter in select * from unnest(new.filters) loop\n            -- Filtered column is valid\n            if not filter.column_name = any(col_names) then\n                raise exception 'invalid column for filter %', filter.column_name;\n            end if;\n\n            -- Type is sanitized and safe for string interpolation\n            col_type = (\n                select atttypid::regtype\n                from pg_catalog.pg_attribute\n                where attrelid = new.entity\n                      and attname = filter.column_name\n            );\n            if col_type is null then\n                raise exception 'failed to lookup type for column %', filter.column_name;\n            end if;\n\n            -- Set maximum number of entries for in filter\n            if filter.op = 'in'::realtime.equality_op then\n                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);\n                if coalesce(jsonb_array_length(in_val), 0) > 100 then\n                    raise exception 'too many values for `in` filter. Maximum 100';\n                end if;\n            else\n                -- raises an exception if value is not coercable to type\n                perform realtime.cast(filter.value, col_type);\n            end if;\n\n        end loop;\n\n        -- Apply consistent order to filters so the unique constraint on\n        -- (subscription_id, entity, filters) can't be tricked by a different filter order\n        new.filters = coalesce(\n            array_agg(f order by f.column_name, f.op, f.value),\n            '{}'\n        ) from unnest(new.filters) f;\n\n        return new;\n    end;\n    ",
    "complete_statement": "CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity\n                and pg_catalog.has_column_privilege(\n                    (new.claims ->> 'role'),\n                    format('%I.%I', c.table_schema, c.table_name)::regclass,\n                    c.column_name,\n                    'SELECT'\n                );\n        filter realtime.user_defined_filter;\n        col_type regtype;\n\n        in_val jsonb;\n    begin\n        for filter in select * from unnest(new.filters) loop\n            -- Filtered column is valid\n            if not filter.column_name = any(col_names) then\n                raise exception 'invalid column for filter %', filter.column_name;\n            end if;\n\n            -- Type is sanitized and safe for string interpolation\n            col_type = (\n                select atttypid::regtype\n                from pg_catalog.pg_attribute\n                where attrelid = new.entity\n                      and attname = filter.column_name\n            );\n            if col_type is null then\n                raise exception 'failed to lookup type for column %', filter.column_name;\n            end if;\n\n            -- Set maximum number of entries for in filter\n            if filter.op = 'in'::realtime.equality_op then\n                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);\n                if coalesce(jsonb_array_length(in_val), 0) > 100 then\n                    raise exception 'too many values for `in` filter. Maximum 100';\n                end if;\n            else\n                -- raises an exception if value is not coercable to type\n                perform realtime.cast(filter.value, col_type);\n            end if;\n\n        end loop;\n\n        -- Apply consistent order to filters so the unique constraint on\n        -- (subscription_id, entity, filters) can't be tricked by a different filter order\n        new.filters = coalesce(\n            array_agg(f order by f.column_name, f.op, f.value),\n            '{}'\n        ) from unnest(new.filters) f;\n\n        return new;\n    end;\n    $function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2279,
    "return_type": "trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17276,
    "schema": "realtime",
    "name": "topic",
    "language": "sql",
    "definition": "\nselect nullif(current_setting('realtime.topic', true), '')::text;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION realtime.topic()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\nselect nullif(current_setting('realtime.topic', true), '')::text;\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17282,
    "schema": "realtime",
    "name": "send",
    "language": "plpgsql",
    "definition": "\nBEGIN\n  BEGIN\n    -- Set the topic configuration\n    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);\n\n    -- Attempt to insert the message\n    INSERT INTO realtime.messages (payload, event, topic, private, extension)\n    VALUES (payload, event, topic, private, 'broadcast');\n  EXCEPTION\n    WHEN OTHERS THEN\n      -- Capture and notify the error\n      PERFORM pg_notify(\n          'realtime:system',\n          jsonb_build_object(\n              'error', SQLERRM,\n              'function', 'realtime.send',\n              'event', event,\n              'topic', topic,\n              'private', private\n          )::text\n      );\n  END;\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  BEGIN\n    -- Set the topic configuration\n    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);\n\n    -- Attempt to insert the message\n    INSERT INTO realtime.messages (payload, event, topic, private, extension)\n    VALUES (payload, event, topic, private, 'broadcast');\n  EXCEPTION\n    WHEN OTHERS THEN\n      -- Capture and notify the error\n      PERFORM pg_notify(\n          'realtime:system',\n          jsonb_build_object(\n              'error', SQLERRM,\n              'function', 'realtime.send',\n              'event', event,\n              'topic', topic,\n              'private', private\n          )::text\n      );\n  END;\nEND;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "payload",
        "type_id": 3802,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "event",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "topic",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "private",
        "type_id": 16,
        "has_default": true
      }
    ],
    "argument_types": "payload jsonb, event text, topic text, private boolean DEFAULT true",
    "identity_argument_types": "payload jsonb, event text, topic text, private boolean",
    "return_type_id": 2278,
    "return_type": "void",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17283,
    "schema": "realtime",
    "name": "broadcast_changes",
    "language": "plpgsql",
    "definition": "\nDECLARE\n    -- Declare a variable to hold the JSONB representation of the row\n    row_data jsonb := '{}'::jsonb;\nBEGIN\n    IF level = 'STATEMENT' THEN\n        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';\n    END IF;\n    -- Check the operation type and handle accordingly\n    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN\n        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);\n        PERFORM realtime.send (row_data, event_name, topic_name);\n    ELSE\n        RAISE EXCEPTION 'Unexpected operation type: %', operation;\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;\nEND;\n\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    -- Declare a variable to hold the JSONB representation of the row\n    row_data jsonb := '{}'::jsonb;\nBEGIN\n    IF level = 'STATEMENT' THEN\n        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';\n    END IF;\n    -- Check the operation type and handle accordingly\n    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN\n        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);\n        PERFORM realtime.send (row_data, event_name, topic_name);\n    ELSE\n        RAISE EXCEPTION 'Unexpected operation type: %', operation;\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;\nEND;\n\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "topic_name",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "event_name",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "operation",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "table_name",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "table_schema",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "new",
        "type_id": 2249,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "old",
        "type_id": 2249,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "level",
        "type_id": 25,
        "has_default": true
      }
    ],
    "argument_types": "topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text",
    "identity_argument_types": "topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text",
    "return_type_id": 2278,
    "return_type": "void",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17320,
    "schema": "storage",
    "name": "foldername",
    "language": "plpgsql",
    "definition": "\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[1:array_length(_parts,1)-1];\nEND\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.foldername(name text)\n RETURNS text[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[1:array_length(_parts,1)-1];\nEND\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "name",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "name text",
    "identity_argument_types": "name text",
    "return_type_id": 1009,
    "return_type": "text[]",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17321,
    "schema": "storage",
    "name": "filename",
    "language": "plpgsql",
    "definition": "\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.filename(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "name",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "name text",
    "identity_argument_types": "name text",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17322,
    "schema": "storage",
    "name": "extension",
    "language": "plpgsql",
    "definition": "\nDECLARE\n_parts text[];\n_filename text;\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\tselect _parts[array_length(_parts,1)] into _filename;\n\t-- @todo return the last part instead of 2\n\treturn reverse(split_part(reverse(_filename), '.', 1));\nEND\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.extension(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\n_filename text;\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\tselect _parts[array_length(_parts,1)] into _filename;\n\t-- @todo return the last part instead of 2\n\treturn reverse(split_part(reverse(_filename), '.', 1));\nEND\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "name",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "name text",
    "identity_argument_types": "name text",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17348,
    "schema": "storage",
    "name": "can_insert_object",
    "language": "plpgsql",
    "definition": "\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "bucketid",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "name",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "owner",
        "type_id": 2950,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "metadata",
        "type_id": 3802,
        "has_default": false
      }
    ],
    "argument_types": "bucketid text, name text, owner uuid, metadata jsonb",
    "identity_argument_types": "bucketid text, name text, owner uuid, metadata jsonb",
    "return_type_id": 2278,
    "return_type": "void",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17334,
    "schema": "storage",
    "name": "get_size_by_bucket",
    "language": "plpgsql",
    "definition": "\nBEGIN\n    return query\n        select sum((metadata->>'size')::int) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()\n RETURNS TABLE(size bigint, bucket_id text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    return query\n        select sum((metadata->>'size')::int) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n$function$\n",
    "args": [
      {
        "mode": "table",
        "name": "size",
        "type_id": 20,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "bucket_id",
        "type_id": 25,
        "has_default": null
      }
    ],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2249,
    "return_type": "TABLE(size bigint, bucket_id text)",
    "return_type_relation_id": null,
    "is_set_returning_function": true,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17338,
    "schema": "storage",
    "name": "update_updated_at_column",
    "language": "plpgsql",
    "definition": "\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2279,
    "return_type": "trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17350,
    "schema": "storage",
    "name": "list_objects_with_delimiter",
    "language": "plpgsql",
    "definition": "\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(name COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))\n                    ELSE\n                        name\n                END AS name, id, metadata, updated_at\n            FROM\n                storage.objects\n            WHERE\n                bucket_id = $5 AND\n                name ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $6 != '''' THEN\n                    name COLLATE \"C\" > $6\n                ELSE true END\n                AND CASE\n                    WHEN $4 != '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                name COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END\n            ORDER BY\n                name COLLATE \"C\" ASC) as e order by name COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)\n RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(name COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))\n                    ELSE\n                        name\n                END AS name, id, metadata, updated_at\n            FROM\n                storage.objects\n            WHERE\n                bucket_id = $5 AND\n                name ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $6 != '''' THEN\n                    name COLLATE \"C\" > $6\n                ELSE true END\n                AND CASE\n                    WHEN $4 != '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                name COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END\n            ORDER BY\n                name COLLATE \"C\" ASC) as e order by name COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;\nEND;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "bucket_id",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "prefix_param",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "delimiter_param",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "max_keys",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "start_after",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "next_token",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "table",
        "name": "name",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "id",
        "type_id": 2950,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "metadata",
        "type_id": 3802,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "updated_at",
        "type_id": 1184,
        "has_default": null
      }
    ],
    "argument_types": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text",
    "identity_argument_types": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer, start_after text, next_token text",
    "return_type_id": 2249,
    "return_type": "TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)",
    "return_type_relation_id": null,
    "is_set_returning_function": true,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17387,
    "schema": "storage",
    "name": "list_multipart_uploads_with_delimiter",
    "language": "plpgsql",
    "definition": "\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE\n                bucket_id = $5 AND\n                key ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $4 != '''' AND $6 = '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                key COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END AND\n                CASE\n                    WHEN $6 != '''' THEN\n                        id COLLATE \"C\" > $6\n                    ELSE\n                        true\n                    END\n            ORDER BY\n                key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)\n RETURNS TABLE(key text, id text, created_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE\n                bucket_id = $5 AND\n                key ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $4 != '''' AND $6 = '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                key COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END AND\n                CASE\n                    WHEN $6 != '''' THEN\n                        id COLLATE \"C\" > $6\n                    ELSE\n                        true\n                    END\n            ORDER BY\n                key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;\nEND;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "bucket_id",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "prefix_param",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "delimiter_param",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "max_keys",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "next_key_token",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "next_upload_token",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "table",
        "name": "key",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "id",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "created_at",
        "type_id": 1184,
        "has_default": null
      }
    ],
    "argument_types": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text",
    "identity_argument_types": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer, next_key_token text, next_upload_token text",
    "return_type_id": 2249,
    "return_type": "TABLE(key text, id text, created_at timestamp with time zone)",
    "return_type_relation_id": null,
    "is_set_returning_function": true,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17403,
    "schema": "storage",
    "name": "operation",
    "language": "plpgsql",
    "definition": "\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.operation()\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17404,
    "schema": "storage",
    "name": "get_level",
    "language": "sql",
    "definition": "\nSELECT array_length(string_to_array(\"name\", '/'), 1);\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.get_level(name text)\n RETURNS integer\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT array_length(string_to_array(\"name\", '/'), 1);\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "name",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "name text",
    "identity_argument_types": "name text",
    "return_type_id": 23,
    "return_type": "integer",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17420,
    "schema": "storage",
    "name": "get_prefix",
    "language": "sql",
    "definition": "\nSELECT\n    CASE WHEN strpos(\"name\", '/') > 0 THEN\n             regexp_replace(\"name\", '[\\/]{1}[^\\/]+\\/?$', '')\n         ELSE\n             ''\n        END;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.get_prefix(name text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT\n    CASE WHEN strpos(\"name\", '/') > 0 THEN\n             regexp_replace(\"name\", '[\\/]{1}[^\\/]+\\/?$', '')\n         ELSE\n             ''\n        END;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "name",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "name text",
    "identity_argument_types": "name text",
    "return_type_id": 25,
    "return_type": "text",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17421,
    "schema": "storage",
    "name": "get_prefixes",
    "language": "plpgsql",
    "definition": "\nDECLARE\n    parts text[];\n    prefixes text[];\n    prefix text;\nBEGIN\n    -- Split the name into parts by '/'\n    parts := string_to_array(\"name\", '/');\n    prefixes := '{}';\n\n    -- Construct the prefixes, stopping one level below the last part\n    FOR i IN 1..array_length(parts, 1) - 1 LOOP\n            prefix := array_to_string(parts[1:i], '/');\n            prefixes := array_append(prefixes, prefix);\n    END LOOP;\n\n    RETURN prefixes;\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.get_prefixes(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE STRICT\nAS $function$\nDECLARE\n    parts text[];\n    prefixes text[];\n    prefix text;\nBEGIN\n    -- Split the name into parts by '/'\n    parts := string_to_array(\"name\", '/');\n    prefixes := '{}';\n\n    -- Construct the prefixes, stopping one level below the last part\n    FOR i IN 1..array_length(parts, 1) - 1 LOOP\n            prefix := array_to_string(parts[1:i], '/');\n            prefixes := array_append(prefixes, prefix);\n    END LOOP;\n\n    RETURN prefixes;\nEND;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "name",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "name text",
    "identity_argument_types": "name text",
    "return_type_id": 1009,
    "return_type": "text[]",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17422,
    "schema": "storage",
    "name": "add_prefixes",
    "language": "plpgsql",
    "definition": "\nDECLARE\n    prefixes text[];\nBEGIN\n    prefixes := \"storage\".\"get_prefixes\"(\"_name\");\n\n    IF array_length(prefixes, 1) > 0 THEN\n        INSERT INTO storage.prefixes (name, bucket_id)\n        SELECT UNNEST(prefixes) as name, \"_bucket_id\" ON CONFLICT DO NOTHING;\n    END IF;\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.add_prefixes(_bucket_id text, _name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    prefixes text[];\nBEGIN\n    prefixes := \"storage\".\"get_prefixes\"(\"_name\");\n\n    IF array_length(prefixes, 1) > 0 THEN\n        INSERT INTO storage.prefixes (name, bucket_id)\n        SELECT UNNEST(prefixes) as name, \"_bucket_id\" ON CONFLICT DO NOTHING;\n    END IF;\nEND;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "_bucket_id",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "_name",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "_bucket_id text, _name text",
    "identity_argument_types": "_bucket_id text, _name text",
    "return_type_id": 2278,
    "return_type": "void",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": null
  },
  {
    "id": 17423,
    "schema": "storage",
    "name": "delete_prefix",
    "language": "plpgsql",
    "definition": "\nBEGIN\n    -- Check if we can delete the prefix\n    IF EXISTS(\n        SELECT FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"prefixes\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    )\n    OR EXISTS(\n        SELECT FROM \"storage\".\"objects\"\n        WHERE \"objects\".\"bucket_id\" = \"_bucket_id\"\n          AND \"storage\".\"get_level\"(\"objects\".\"name\") = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"objects\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    ) THEN\n    -- There are sub-objects, skip deletion\n    RETURN false;\n    ELSE\n        DELETE FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\")\n          AND \"prefixes\".\"name\" = \"_name\";\n        RETURN true;\n    END IF;\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.delete_prefix(_bucket_id text, _name text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if we can delete the prefix\n    IF EXISTS(\n        SELECT FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"prefixes\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    )\n    OR EXISTS(\n        SELECT FROM \"storage\".\"objects\"\n        WHERE \"objects\".\"bucket_id\" = \"_bucket_id\"\n          AND \"storage\".\"get_level\"(\"objects\".\"name\") = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"objects\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    ) THEN\n    -- There are sub-objects, skip deletion\n    RETURN false;\n    ELSE\n        DELETE FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\")\n          AND \"prefixes\".\"name\" = \"_name\";\n        RETURN true;\n    END IF;\nEND;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "_bucket_id",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "_name",
        "type_id": 25,
        "has_default": false
      }
    ],
    "argument_types": "_bucket_id text, _name text",
    "identity_argument_types": "_bucket_id text, _name text",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": true,
    "config_params": null
  },
  {
    "id": 17424,
    "schema": "storage",
    "name": "prefixes_insert_trigger",
    "language": "plpgsql",
    "definition": "\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    RETURN NEW;\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.prefixes_insert_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    RETURN NEW;\nEND;\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2279,
    "return_type": "trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17425,
    "schema": "storage",
    "name": "objects_insert_prefix_trigger",
    "language": "plpgsql",
    "definition": "\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    NEW.level := \"storage\".\"get_level\"(NEW.\"name\");\n\n    RETURN NEW;\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.objects_insert_prefix_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    NEW.level := \"storage\".\"get_level\"(NEW.\"name\");\n\n    RETURN NEW;\nEND;\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2279,
    "return_type": "trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17426,
    "schema": "storage",
    "name": "delete_prefix_hierarchy_trigger",
    "language": "plpgsql",
    "definition": "\nDECLARE\n    prefix text;\nBEGIN\n    prefix := \"storage\".\"get_prefix\"(OLD.\"name\");\n\n    IF coalesce(prefix, '') != '' THEN\n        PERFORM \"storage\".\"delete_prefix\"(OLD.\"bucket_id\", prefix);\n    END IF;\n\n    RETURN OLD;\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.delete_prefix_hierarchy_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    prefix text;\nBEGIN\n    prefix := \"storage\".\"get_prefix\"(OLD.\"name\");\n\n    IF coalesce(prefix, '') != '' THEN\n        PERFORM \"storage\".\"delete_prefix\"(OLD.\"bucket_id\", prefix);\n    END IF;\n\n    RETURN OLD;\nEND;\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 2279,
    "return_type": "trigger",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "VOLATILE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17431,
    "schema": "storage",
    "name": "search_v2",
    "language": "plpgsql",
    "definition": "\nBEGIN\n    RETURN query EXECUTE\n        $sql$\n        SELECT * FROM (\n            (\n                SELECT\n                    split_part(name, '/', $4) AS key,\n                    name || '/' AS name,\n                    NULL::uuid AS id,\n                    NULL::timestamptz AS updated_at,\n                    NULL::timestamptz AS created_at,\n                    NULL::jsonb AS metadata\n                FROM storage.prefixes\n                WHERE name COLLATE \"C\" LIKE $1 || '%'\n                AND bucket_id = $2\n                AND level = $4\n                AND name COLLATE \"C\" > $5\n                ORDER BY prefixes.name COLLATE \"C\" LIMIT $3\n            )\n            UNION ALL\n            (SELECT split_part(name, '/', $4) AS key,\n                name,\n                id,\n                updated_at,\n                created_at,\n                metadata\n            FROM storage.objects\n            WHERE name COLLATE \"C\" LIKE $1 || '%'\n                AND bucket_id = $2\n                AND level = $4\n                AND name COLLATE \"C\" > $5\n            ORDER BY name COLLATE \"C\" LIMIT $3)\n        ) obj\n        ORDER BY name COLLATE \"C\" LIMIT $3;\n        $sql$\n        USING prefix, bucket_name, limits, levels, start_after;\nEND;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text)\n RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN query EXECUTE\n        $sql$\n        SELECT * FROM (\n            (\n                SELECT\n                    split_part(name, '/', $4) AS key,\n                    name || '/' AS name,\n                    NULL::uuid AS id,\n                    NULL::timestamptz AS updated_at,\n                    NULL::timestamptz AS created_at,\n                    NULL::jsonb AS metadata\n                FROM storage.prefixes\n                WHERE name COLLATE \"C\" LIKE $1 || '%'\n                AND bucket_id = $2\n                AND level = $4\n                AND name COLLATE \"C\" > $5\n                ORDER BY prefixes.name COLLATE \"C\" LIMIT $3\n            )\n            UNION ALL\n            (SELECT split_part(name, '/', $4) AS key,\n                name,\n                id,\n                updated_at,\n                created_at,\n                metadata\n            FROM storage.objects\n            WHERE name COLLATE \"C\" LIKE $1 || '%'\n                AND bucket_id = $2\n                AND level = $4\n                AND name COLLATE \"C\" > $5\n            ORDER BY name COLLATE \"C\" LIMIT $3)\n        ) obj\n        ORDER BY name COLLATE \"C\" LIMIT $3;\n        $sql$\n        USING prefix, bucket_name, limits, levels, start_after;\nEND;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "prefix",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "bucket_name",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "limits",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "levels",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "start_after",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "table",
        "name": "key",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "name",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "id",
        "type_id": 2950,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "updated_at",
        "type_id": 1184,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "created_at",
        "type_id": 1184,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "metadata",
        "type_id": 3802,
        "has_default": null
      }
    ],
    "argument_types": "prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text",
    "identity_argument_types": "prefix text, bucket_name text, limits integer, levels integer, start_after text",
    "return_type_id": 2249,
    "return_type": "TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, metadata jsonb)",
    "return_type_relation_id": null,
    "is_set_returning_function": true,
    "behavior": "STABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17873,
    "schema": "public",
    "name": "subvector",
    "language": "c",
    "definition": "halfvec_subvector",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.subvector(halfvec, integer, integer)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_subvector$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, integer, integer",
    "identity_argument_types": "halfvec, integer, integer",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17874,
    "schema": "public",
    "name": "halfvec_add",
    "language": "c",
    "definition": "halfvec_add",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_add(halfvec, halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_add$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17875,
    "schema": "public",
    "name": "halfvec_sub",
    "language": "c",
    "definition": "halfvec_sub",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_sub(halfvec, halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_sub$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17876,
    "schema": "public",
    "name": "halfvec_mul",
    "language": "c",
    "definition": "halfvec_mul",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_mul(halfvec, halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_mul$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17877,
    "schema": "public",
    "name": "halfvec_concat",
    "language": "c",
    "definition": "halfvec_concat",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_concat(halfvec, halfvec)\n RETURNS halfvec\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_concat$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 17858,
    "return_type": "halfvec",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17878,
    "schema": "public",
    "name": "halfvec_lt",
    "language": "c",
    "definition": "halfvec_lt",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_lt(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_lt$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17879,
    "schema": "public",
    "name": "halfvec_le",
    "language": "c",
    "definition": "halfvec_le",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_le(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_le$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17880,
    "schema": "public",
    "name": "halfvec_eq",
    "language": "c",
    "definition": "halfvec_eq",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.halfvec_eq(halfvec, halfvec)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$halfvec_eq$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17858,
        "has_default": false
      }
    ],
    "argument_types": "halfvec, halfvec",
    "identity_argument_types": "halfvec, halfvec",
    "return_type_id": 16,
    "return_type": "boolean",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17436,
    "schema": "storage",
    "name": "search_v1_optimised",
    "language": "plpgsql",
    "definition": "\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select (string_to_array(name, ''/''))[level] as name\n           from storage.prefixes\n             where lower(prefixes.name) like lower($2 || $3) || ''%''\n               and bucket_id = $4\n               and level = $1\n           order by name ' || v_sort_order || '\n     )\n     (select name,\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[level] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where lower(objects.name) like lower($2 || $3) || ''%''\n       and bucket_id = $4\n       and level = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select (string_to_array(name, ''/''))[level] as name\n           from storage.prefixes\n             where lower(prefixes.name) like lower($2 || $3) || ''%''\n               and bucket_id = $4\n               and level = $1\n           order by name ' || v_sort_order || '\n     )\n     (select name,\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[level] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where lower(objects.name) like lower($2 || $3) || ''%''\n       and bucket_id = $4\n       and level = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "prefix",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "bucketname",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "limits",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "levels",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "offsets",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "search",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "sortcolumn",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "sortorder",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "table",
        "name": "name",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "id",
        "type_id": 2950,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "updated_at",
        "type_id": 1184,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "created_at",
        "type_id": 1184,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "last_accessed_at",
        "type_id": 1184,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "metadata",
        "type_id": 3802,
        "has_default": null
      }
    ],
    "argument_types": "prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text",
    "identity_argument_types": "prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text",
    "return_type_id": 2249,
    "return_type": "TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
    "return_type_relation_id": null,
    "is_set_returning_function": true,
    "behavior": "STABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17437,
    "schema": "storage",
    "name": "search_legacy_v1",
    "language": "plpgsql",
    "definition": "\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select path_tokens[$1] as folder\n           from storage.objects\n             where objects.name ilike $2 || $3 || ''%''\n               and bucket_id = $4\n               and array_length(objects.path_tokens, 1) <> $1\n           group by folder\n           order by folder ' || v_sort_order || '\n     )\n     (select folder as \"name\",\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[$1] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where objects.name ilike $2 || $3 || ''%''\n       and bucket_id = $4\n       and array_length(objects.path_tokens, 1) = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select path_tokens[$1] as folder\n           from storage.objects\n             where objects.name ilike $2 || $3 || ''%''\n               and bucket_id = $4\n               and array_length(objects.path_tokens, 1) <> $1\n           group by folder\n           order by folder ' || v_sort_order || '\n     )\n     (select folder as \"name\",\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[$1] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where objects.name ilike $2 || $3 || ''%''\n       and bucket_id = $4\n       and array_length(objects.path_tokens, 1) = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "prefix",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "bucketname",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "limits",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "levels",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "offsets",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "search",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "sortcolumn",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "sortorder",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "table",
        "name": "name",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "id",
        "type_id": 2950,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "updated_at",
        "type_id": 1184,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "created_at",
        "type_id": 1184,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "last_accessed_at",
        "type_id": 1184,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "metadata",
        "type_id": 3802,
        "has_default": null
      }
    ],
    "argument_types": "prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text",
    "identity_argument_types": "prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text",
    "return_type_id": 2249,
    "return_type": "TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
    "return_type_relation_id": null,
    "is_set_returning_function": true,
    "behavior": "STABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17337,
    "schema": "storage",
    "name": "search",
    "language": "plpgsql",
    "definition": "\ndeclare\n    can_bypass_rls BOOLEAN;\nbegin\n    SELECT rolbypassrls\n    INTO can_bypass_rls\n    FROM pg_roles\n    WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);\n\n    IF can_bypass_rls THEN\n        RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    ELSE\n        RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    END IF;\nend;\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    can_bypass_rls BOOLEAN;\nbegin\n    SELECT rolbypassrls\n    INTO can_bypass_rls\n    FROM pg_roles\n    WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);\n\n    IF can_bypass_rls THEN\n        RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    ELSE\n        RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    END IF;\nend;\n$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "prefix",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "bucketname",
        "type_id": 25,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "limits",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "levels",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "offsets",
        "type_id": 23,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "search",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "sortcolumn",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "in",
        "name": "sortorder",
        "type_id": 25,
        "has_default": true
      },
      {
        "mode": "table",
        "name": "name",
        "type_id": 25,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "id",
        "type_id": 2950,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "updated_at",
        "type_id": 1184,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "created_at",
        "type_id": 1184,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "last_accessed_at",
        "type_id": 1184,
        "has_default": null
      },
      {
        "mode": "table",
        "name": "metadata",
        "type_id": 3802,
        "has_default": null
      }
    ],
    "argument_types": "prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text",
    "identity_argument_types": "prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text",
    "return_type_id": 2249,
    "return_type": "TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
    "return_type_relation_id": null,
    "is_set_returning_function": true,
    "behavior": "STABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17486,
    "schema": "auth",
    "name": "jwt",
    "language": "sql",
    "definition": "\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n",
    "complete_statement": "CREATE OR REPLACE FUNCTION auth.jwt()\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n$function$\n",
    "args": [],
    "argument_types": "",
    "identity_argument_types": "",
    "return_type_id": 3802,
    "return_type": "jsonb",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "STABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17746,
    "schema": "public",
    "name": "vector_in",
    "language": "c",
    "definition": "vector_in",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_in(cstring, oid, integer)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_in$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 2275,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 26,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      }
    ],
    "argument_types": "cstring, oid, integer",
    "identity_argument_types": "cstring, oid, integer",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17747,
    "schema": "public",
    "name": "vector_out",
    "language": "c",
    "definition": "vector_out",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_out(vector)\n RETURNS cstring\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_out$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector",
    "identity_argument_types": "vector",
    "return_type_id": 2275,
    "return_type": "cstring",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17748,
    "schema": "public",
    "name": "vector_typmod_in",
    "language": "c",
    "definition": "vector_typmod_in",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_typmod_in(cstring[])\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_typmod_in$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 1263,
        "has_default": false
      }
    ],
    "argument_types": "cstring[]",
    "identity_argument_types": "cstring[]",
    "return_type_id": 23,
    "return_type": "integer",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17749,
    "schema": "public",
    "name": "vector_recv",
    "language": "c",
    "definition": "vector_recv",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_recv(internal, oid, integer)\n RETURNS vector\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_recv$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 2281,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 26,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 23,
        "has_default": false
      }
    ],
    "argument_types": "internal, oid, integer",
    "identity_argument_types": "internal, oid, integer",
    "return_type_id": 17745,
    "return_type": "vector",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17750,
    "schema": "public",
    "name": "vector_send",
    "language": "c",
    "definition": "vector_send",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.vector_send(vector)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$vector_send$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector",
    "identity_argument_types": "vector",
    "return_type_id": 17,
    "return_type": "bytea",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17752,
    "schema": "public",
    "name": "l2_distance",
    "language": "c",
    "definition": "l2_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.l2_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$l2_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17753,
    "schema": "public",
    "name": "inner_product",
    "language": "c",
    "definition": "inner_product",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.inner_product(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$inner_product$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17754,
    "schema": "public",
    "name": "cosine_distance",
    "language": "c",
    "definition": "cosine_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.cosine_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$cosine_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  },
  {
    "id": 17755,
    "schema": "public",
    "name": "l1_distance",
    "language": "c",
    "definition": "l1_distance",
    "complete_statement": "CREATE OR REPLACE FUNCTION public.l1_distance(vector, vector)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/vector', $function$l1_distance$function$\n",
    "args": [
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      },
      {
        "mode": "in",
        "name": "",
        "type_id": 17745,
        "has_default": false
      }
    ],
    "argument_types": "vector, vector",
    "identity_argument_types": "vector, vector",
    "return_type_id": 701,
    "return_type": "double precision",
    "return_type_relation_id": null,
    "is_set_returning_function": false,
    "behavior": "IMMUTABLE",
    "security_definer": false,
    "config_params": null
  }
]
